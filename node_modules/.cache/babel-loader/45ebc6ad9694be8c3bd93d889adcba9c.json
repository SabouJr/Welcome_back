{"ast":null,"code":"import React from 'react';\nimport PropTypes from 'prop-types';\n\nfunction unwrapExports(x) {\n  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x.default : x;\n}\n\nfunction createCommonjsModule(fn, module) {\n  return module = {\n    exports: {}\n  }, fn(module, module.exports), module.exports;\n}\n\nvar wavesurfer_min = createCommonjsModule(function (module, exports) {\n  !function (e, t) {\n    module.exports = t();\n  }(window, function () {\n    return function (e) {\n      var t = {};\n\n      function r(n) {\n        if (t[n]) return t[n].exports;\n        var i = t[n] = {\n          i: n,\n          l: !1,\n          exports: {}\n        };\n        return e[n].call(i.exports, i, i.exports, r), i.l = !0, i.exports;\n      }\n\n      return r.m = e, r.c = t, r.d = function (e, t, n) {\n        r.o(e, t) || Object.defineProperty(e, t, {\n          enumerable: !0,\n          get: n\n        });\n      }, r.r = function (e) {\n        \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {\n          value: \"Module\"\n        }), Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        });\n      }, r.t = function (e, t) {\n        if (1 & t && (e = r(e)), 8 & t) return e;\n        if (4 & t && \"object\" == typeof e && e && e.__esModule) return e;\n        var n = Object.create(null);\n        if (r.r(n), Object.defineProperty(n, \"default\", {\n          enumerable: !0,\n          value: e\n        }), 2 & t && \"string\" != typeof e) for (var i in e) r.d(n, i, function (t) {\n          return e[t];\n        }.bind(null, i));\n        return n;\n      }, r.n = function (e) {\n        var t = e && e.__esModule ? function () {\n          return e.default;\n        } : function () {\n          return e;\n        };\n        return r.d(t, \"a\", t), t;\n      }, r.o = function (e, t) {\n        return Object.prototype.hasOwnProperty.call(e, t);\n      }, r.p = \"\", r(r.s = 4);\n    }([function (e, t, r) {\n      Object.defineProperty(t, \"__esModule\", {\n        value: !0\n      }), Object.defineProperty(t, \"ajax\", {\n        enumerable: !0,\n        get: function () {\n          return n.default;\n        }\n      }), Object.defineProperty(t, \"getId\", {\n        enumerable: !0,\n        get: function () {\n          return i.default;\n        }\n      }), Object.defineProperty(t, \"max\", {\n        enumerable: !0,\n        get: function () {\n          return a.default;\n        }\n      }), Object.defineProperty(t, \"min\", {\n        enumerable: !0,\n        get: function () {\n          return s.default;\n        }\n      }), Object.defineProperty(t, \"Observer\", {\n        enumerable: !0,\n        get: function () {\n          return o.default;\n        }\n      }), Object.defineProperty(t, \"extend\", {\n        enumerable: !0,\n        get: function () {\n          return u.default;\n        }\n      }), Object.defineProperty(t, \"style\", {\n        enumerable: !0,\n        get: function () {\n          return l.default;\n        }\n      }), Object.defineProperty(t, \"requestAnimationFrame\", {\n        enumerable: !0,\n        get: function () {\n          return c.default;\n        }\n      }), Object.defineProperty(t, \"frame\", {\n        enumerable: !0,\n        get: function () {\n          return h.default;\n        }\n      }), Object.defineProperty(t, \"debounce\", {\n        enumerable: !0,\n        get: function () {\n          return f.default;\n        }\n      }), Object.defineProperty(t, \"preventClick\", {\n        enumerable: !0,\n        get: function () {\n          return d.default;\n        }\n      });\n      var n = p(r(5)),\n          i = p(r(6)),\n          a = p(r(7)),\n          s = p(r(8)),\n          o = p(r(1)),\n          u = p(r(9)),\n          l = p(r(10)),\n          c = p(r(2)),\n          h = p(r(11)),\n          f = p(r(12)),\n          d = p(r(13));\n\n      function p(e) {\n        return e && e.__esModule ? e : {\n          default: e\n        };\n      }\n    }, function (e, t, r) {\n      function n(e, t) {\n        for (var r = 0; r < t.length; r++) {\n          var n = t[r];\n          n.enumerable = n.enumerable || !1, n.configurable = !0, \"value\" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);\n        }\n      }\n\n      Object.defineProperty(t, \"__esModule\", {\n        value: !0\n      }), t.default = void 0;\n\n      var i = function () {\n        function e() {\n          !function (e, t) {\n            if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n          }(this, e), this.handlers = null;\n        }\n\n        var t, r;\n        return t = e, (r = [{\n          key: \"on\",\n          value: function (e, t) {\n            var r = this;\n            this.handlers || (this.handlers = {});\n            var n = this.handlers[e];\n            return n || (n = this.handlers[e] = []), n.push(t), {\n              name: e,\n              callback: t,\n              un: function (e, t) {\n                return r.un(e, t);\n              }\n            };\n          }\n        }, {\n          key: \"un\",\n          value: function (e, t) {\n            if (this.handlers) {\n              var r,\n                  n = this.handlers[e];\n              if (n) if (t) for (r = n.length - 1; r >= 0; r--) n[r] == t && n.splice(r, 1);else n.length = 0;\n            }\n          }\n        }, {\n          key: \"unAll\",\n          value: function () {\n            this.handlers = null;\n          }\n        }, {\n          key: \"once\",\n          value: function (e, t) {\n            var r = this;\n            return this.on(e, function n() {\n              for (var i = arguments.length, a = new Array(i), s = 0; s < i; s++) a[s] = arguments[s];\n\n              t.apply(r, a), setTimeout(function () {\n                r.un(e, n);\n              }, 0);\n            });\n          }\n        }, {\n          key: \"fireEvent\",\n          value: function (e) {\n            for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++) r[n - 1] = arguments[n];\n\n            if (this.handlers) {\n              var i = this.handlers[e];\n              i && i.forEach(function (e) {\n                e.apply(void 0, r);\n              });\n            }\n          }\n        }]) && n(t.prototype, r), e;\n      }();\n\n      t.default = i, e.exports = t.default;\n    }, function (e, t, r) {\n      Object.defineProperty(t, \"__esModule\", {\n        value: !0\n      }), t.default = void 0;\n\n      var n = (window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (e, t) {\n        return setTimeout(e, 1e3 / 60);\n      }).bind(window);\n\n      t.default = n, e.exports = t.default;\n    }, function (e, t, r) {\n      Object.defineProperty(t, \"__esModule\", {\n        value: !0\n      }), t.default = void 0;\n\n      var n = function (e) {\n        if (e && e.__esModule) return e;\n        var t = {};\n        if (null != e) for (var r in e) if (Object.prototype.hasOwnProperty.call(e, r)) {\n          var n = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(e, r) : {};\n          n.get || n.set ? Object.defineProperty(t, r, n) : t[r] = e[r];\n        }\n        return t.default = e, t;\n      }(r(0));\n\n      function i(e) {\n        return (i = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (e) {\n          return typeof e;\n        } : function (e) {\n          return e && \"function\" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? \"symbol\" : typeof e;\n        })(e);\n      }\n\n      function a(e, t, r) {\n        return t in e ? Object.defineProperty(e, t, {\n          value: r,\n          enumerable: !0,\n          configurable: !0,\n          writable: !0\n        }) : e[t] = r, e;\n      }\n\n      function s(e, t) {\n        return !t || \"object\" !== i(t) && \"function\" != typeof t ? function (e) {\n          if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n          return e;\n        }(e) : t;\n      }\n\n      function o(e) {\n        return (o = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) {\n          return e.__proto__ || Object.getPrototypeOf(e);\n        })(e);\n      }\n\n      function u(e, t) {\n        for (var r = 0; r < t.length; r++) {\n          var n = t[r];\n          n.enumerable = n.enumerable || !1, n.configurable = !0, \"value\" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);\n        }\n      }\n\n      function l(e, t, r) {\n        return t && u(e.prototype, t), r && u(e, r), e;\n      }\n\n      function c(e, t) {\n        return (c = Object.setPrototypeOf || function (e, t) {\n          return e.__proto__ = t, e;\n        })(e, t);\n      }\n\n      var h = \"playing\",\n          f = \"paused\",\n          d = \"finished\",\n          p = function (e) {\n        function t(e) {\n          var r, n, i;\n          return function (e, t) {\n            if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n          }(this, t), (i = s(this, o(t).call(this))).audioContext = null, i.offlineAudioContext = null, i.stateBehaviors = (a(r = {}, h, {\n            init: function () {\n              this.addOnAudioProcess();\n            },\n            getPlayedPercents: function () {\n              var e = this.getDuration();\n              return this.getCurrentTime() / e || 0;\n            },\n            getCurrentTime: function () {\n              return this.startPosition + this.getPlayedTime();\n            }\n          }), a(r, f, {\n            init: function () {\n              this.removeOnAudioProcess();\n            },\n            getPlayedPercents: function () {\n              var e = this.getDuration();\n              return this.getCurrentTime() / e || 0;\n            },\n            getCurrentTime: function () {\n              return this.startPosition;\n            }\n          }), a(r, d, {\n            init: function () {\n              this.removeOnAudioProcess(), this.fireEvent(\"finish\");\n            },\n            getPlayedPercents: function () {\n              return 1;\n            },\n            getCurrentTime: function () {\n              return this.getDuration();\n            }\n          }), r), i.params = e, i.ac = e.audioContext || i.getAudioContext(), i.lastPlay = i.ac.currentTime, i.startPosition = 0, i.scheduledPause = null, i.states = (a(n = {}, h, Object.create(i.stateBehaviors[h])), a(n, f, Object.create(i.stateBehaviors[f])), a(n, d, Object.create(i.stateBehaviors[d])), n), i.analyser = null, i.buffer = null, i.filters = [], i.gainNode = null, i.mergedPeaks = null, i.offlineAc = null, i.peaks = null, i.playbackRate = 1, i.analyser = null, i.scriptNode = null, i.source = null, i.splitPeaks = [], i.state = null, i.explicitDuration = e.duration, i;\n        }\n\n        return function (e, t) {\n          if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function\");\n          e.prototype = Object.create(t && t.prototype, {\n            constructor: {\n              value: e,\n              writable: !0,\n              configurable: !0\n            }\n          }), t && c(e, t);\n        }(t, n.Observer), l(t, [{\n          key: \"supportsWebAudio\",\n          value: function () {\n            return !(!window.AudioContext && !window.webkitAudioContext);\n          }\n        }, {\n          key: \"getAudioContext\",\n          value: function () {\n            return window.WaveSurferAudioContext || (window.WaveSurferAudioContext = new (window.AudioContext || window.webkitAudioContext)()), window.WaveSurferAudioContext;\n          }\n        }, {\n          key: \"getOfflineAudioContext\",\n          value: function (e) {\n            return window.WaveSurferOfflineAudioContext || (window.WaveSurferOfflineAudioContext = new (window.OfflineAudioContext || window.webkitOfflineAudioContext)(1, 2, e)), window.WaveSurferOfflineAudioContext;\n          }\n        }]), l(t, [{\n          key: \"init\",\n          value: function () {\n            this.createVolumeNode(), this.createScriptNode(), this.createAnalyserNode(), this.setState(f), this.setPlaybackRate(this.params.audioRate), this.setLength(0);\n          }\n        }, {\n          key: \"disconnectFilters\",\n          value: function () {\n            this.filters && (this.filters.forEach(function (e) {\n              e && e.disconnect();\n            }), this.filters = null, this.analyser.connect(this.gainNode));\n          }\n        }, {\n          key: \"setState\",\n          value: function (e) {\n            this.state !== this.states[e] && (this.state = this.states[e], this.state.init.call(this));\n          }\n        }, {\n          key: \"setFilter\",\n          value: function () {\n            for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];\n\n            this.setFilters(t);\n          }\n        }, {\n          key: \"setFilters\",\n          value: function (e) {\n            this.disconnectFilters(), e && e.length && (this.filters = e, this.analyser.disconnect(), e.reduce(function (e, t) {\n              return e.connect(t), t;\n            }, this.analyser).connect(this.gainNode));\n          }\n        }, {\n          key: \"createScriptNode\",\n          value: function () {\n            this.params.audioScriptProcessor ? this.scriptNode = this.params.audioScriptProcessor : this.ac.createScriptProcessor ? this.scriptNode = this.ac.createScriptProcessor(t.scriptBufferSize) : this.scriptNode = this.ac.createJavaScriptNode(t.scriptBufferSize), this.scriptNode.connect(this.ac.destination);\n          }\n        }, {\n          key: \"addOnAudioProcess\",\n          value: function () {\n            var e = this;\n\n            this.scriptNode.onaudioprocess = function () {\n              var t = e.getCurrentTime();\n              t >= e.getDuration() ? (e.setState(d), e.fireEvent(\"pause\")) : t >= e.scheduledPause ? e.pause() : e.state === e.states[h] && e.fireEvent(\"audioprocess\", t);\n            };\n          }\n        }, {\n          key: \"removeOnAudioProcess\",\n          value: function () {\n            this.scriptNode.onaudioprocess = function () {};\n          }\n        }, {\n          key: \"createAnalyserNode\",\n          value: function () {\n            this.analyser = this.ac.createAnalyser(), this.analyser.connect(this.gainNode);\n          }\n        }, {\n          key: \"createVolumeNode\",\n          value: function () {\n            this.ac.createGain ? this.gainNode = this.ac.createGain() : this.gainNode = this.ac.createGainNode(), this.gainNode.connect(this.ac.destination);\n          }\n        }, {\n          key: \"setSinkId\",\n          value: function (e) {\n            if (e) {\n              var t = new window.Audio();\n              if (!t.setSinkId) return Promise.reject(new Error(\"setSinkId is not supported in your browser\"));\n              t.autoplay = !0;\n              var r = this.ac.createMediaStreamDestination();\n              return this.gainNode.disconnect(), this.gainNode.connect(r), t.srcObject = r.stream, t.setSinkId(e);\n            }\n\n            return Promise.reject(new Error(\"Invalid deviceId: \" + e));\n          }\n        }, {\n          key: \"setVolume\",\n          value: function (e) {\n            this.gainNode.gain.setValueAtTime(e, this.ac.currentTime);\n          }\n        }, {\n          key: \"getVolume\",\n          value: function () {\n            return this.gainNode.gain.value;\n          }\n        }, {\n          key: \"decodeArrayBuffer\",\n          value: function (e, t, r) {\n            this.offlineAc || (this.offlineAc = this.getOfflineAudioContext(this.ac && this.ac.sampleRate ? this.ac.sampleRate : 44100)), this.offlineAc.decodeAudioData(e, function (e) {\n              return t(e);\n            }, r);\n          }\n        }, {\n          key: \"setPeaks\",\n          value: function (e, t) {\n            null != t && (this.explicitDuration = t), this.peaks = e;\n          }\n        }, {\n          key: \"setLength\",\n          value: function (e) {\n            if (!this.mergedPeaks || e != 2 * this.mergedPeaks.length - 1 + 2) {\n              this.splitPeaks = [], this.mergedPeaks = [];\n              var t,\n                  r = this.buffer ? this.buffer.numberOfChannels : 1;\n\n              for (t = 0; t < r; t++) this.splitPeaks[t] = [], this.splitPeaks[t][2 * (e - 1)] = 0, this.splitPeaks[t][2 * (e - 1) + 1] = 0;\n\n              this.mergedPeaks[2 * (e - 1)] = 0, this.mergedPeaks[2 * (e - 1) + 1] = 0;\n            }\n          }\n        }, {\n          key: \"getPeaks\",\n          value: function (e, t, r) {\n            if (this.peaks) return this.peaks;\n            if (!this.buffer) return [];\n            if (t = t || 0, r = r || e - 1, this.setLength(e), !this.buffer) return this.params.splitChannels ? this.splitPeaks : this.mergedPeaks;\n\n            if (!this.buffer.length) {\n              var n = this.createBuffer(1, 4096, this.sampleRate);\n              this.buffer = n.buffer;\n            }\n\n            var i,\n                a = this.buffer.length / e,\n                s = ~~(a / 10) || 1,\n                o = this.buffer.numberOfChannels;\n\n            for (i = 0; i < o; i++) {\n              var u = this.splitPeaks[i],\n                  l = this.buffer.getChannelData(i),\n                  c = void 0;\n\n              for (c = t; c <= r; c++) {\n                var h = ~~(c * a),\n                    f = ~~(h + a),\n                    d = 0,\n                    p = 0,\n                    v = void 0;\n\n                for (v = h; v < f; v += s) {\n                  var y = l[v];\n                  y > p && (p = y), y < d && (d = y);\n                }\n\n                u[2 * c] = p, u[2 * c + 1] = d, (0 == i || p > this.mergedPeaks[2 * c]) && (this.mergedPeaks[2 * c] = p), (0 == i || d < this.mergedPeaks[2 * c + 1]) && (this.mergedPeaks[2 * c + 1] = d);\n              }\n            }\n\n            return this.params.splitChannels ? this.splitPeaks : this.mergedPeaks;\n          }\n        }, {\n          key: \"getPlayedPercents\",\n          value: function () {\n            return this.state.getPlayedPercents.call(this);\n          }\n        }, {\n          key: \"disconnectSource\",\n          value: function () {\n            this.source && this.source.disconnect();\n          }\n        }, {\n          key: \"destroy\",\n          value: function () {\n            this.isPaused() || this.pause(), this.unAll(), this.buffer = null, this.disconnectFilters(), this.disconnectSource(), this.gainNode.disconnect(), this.scriptNode.disconnect(), this.analyser.disconnect(), this.params.closeAudioContext && (\"function\" == typeof this.ac.close && \"closed\" != this.ac.state && this.ac.close(), this.ac = null, this.params.audioContext ? this.params.audioContext = null : window.WaveSurferAudioContext = null, window.WaveSurferOfflineAudioContext = null);\n          }\n        }, {\n          key: \"load\",\n          value: function (e) {\n            this.startPosition = 0, this.lastPlay = this.ac.currentTime, this.buffer = e, this.createSource();\n          }\n        }, {\n          key: \"createSource\",\n          value: function () {\n            this.disconnectSource(), this.source = this.ac.createBufferSource(), this.source.start = this.source.start || this.source.noteGrainOn, this.source.stop = this.source.stop || this.source.noteOff, this.source.playbackRate.setValueAtTime(this.playbackRate, this.ac.currentTime), this.source.buffer = this.buffer, this.source.connect(this.analyser);\n          }\n        }, {\n          key: \"isPaused\",\n          value: function () {\n            return this.state !== this.states[h];\n          }\n        }, {\n          key: \"getDuration\",\n          value: function () {\n            return this.explicitDuration ? this.explicitDuration : this.buffer ? this.buffer.duration : 0;\n          }\n        }, {\n          key: \"seekTo\",\n          value: function (e, t) {\n            if (this.buffer) return this.scheduledPause = null, null == e && (e = this.getCurrentTime()) >= this.getDuration() && (e = 0), null == t && (t = this.getDuration()), this.startPosition = e, this.lastPlay = this.ac.currentTime, this.state === this.states[d] && this.setState(f), {\n              start: e,\n              end: t\n            };\n          }\n        }, {\n          key: \"getPlayedTime\",\n          value: function () {\n            return (this.ac.currentTime - this.lastPlay) * this.playbackRate;\n          }\n        }, {\n          key: \"play\",\n          value: function (e, t) {\n            if (this.buffer) {\n              this.createSource();\n              var r = this.seekTo(e, t);\n              e = r.start, t = r.end, this.scheduledPause = t, this.source.start(0, e, t - e), \"suspended\" == this.ac.state && this.ac.resume && this.ac.resume(), this.setState(h), this.fireEvent(\"play\");\n            }\n          }\n        }, {\n          key: \"pause\",\n          value: function () {\n            this.scheduledPause = null, this.startPosition += this.getPlayedTime(), this.source && this.source.stop(0), this.setState(f), this.fireEvent(\"pause\");\n          }\n        }, {\n          key: \"getCurrentTime\",\n          value: function () {\n            return this.state.getCurrentTime.call(this);\n          }\n        }, {\n          key: \"getPlaybackRate\",\n          value: function () {\n            return this.playbackRate;\n          }\n        }, {\n          key: \"setPlaybackRate\",\n          value: function (e) {\n            e = e || 1, this.isPaused() ? this.playbackRate = e : (this.pause(), this.playbackRate = e, this.play());\n          }\n        }]), t;\n      }();\n\n      t.default = p, p.scriptBufferSize = 256, e.exports = t.default;\n    }, function (e, t, r) {\n      Object.defineProperty(t, \"__esModule\", {\n        value: !0\n      }), t.default = void 0;\n\n      var n = function (e) {\n        if (e && e.__esModule) return e;\n        var t = {};\n        if (null != e) for (var r in e) if (Object.prototype.hasOwnProperty.call(e, r)) {\n          var n = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(e, r) : {};\n          n.get || n.set ? Object.defineProperty(t, r, n) : t[r] = e[r];\n        }\n        return t.default = e, t;\n      }(r(0)),\n          i = u(r(14)),\n          a = u(r(3)),\n          s = u(r(16)),\n          o = u(r(17));\n\n      function u(e) {\n        return e && e.__esModule ? e : {\n          default: e\n        };\n      }\n\n      function l(e) {\n        return (l = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (e) {\n          return typeof e;\n        } : function (e) {\n          return e && \"function\" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? \"symbol\" : typeof e;\n        })(e);\n      }\n\n      function c(e, t) {\n        return !t || \"object\" !== l(t) && \"function\" != typeof t ? f(e) : t;\n      }\n\n      function h(e) {\n        return (h = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) {\n          return e.__proto__ || Object.getPrototypeOf(e);\n        })(e);\n      }\n\n      function f(e) {\n        if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        return e;\n      }\n\n      function d(e, t) {\n        return (d = Object.setPrototypeOf || function (e, t) {\n          return e.__proto__ = t, e;\n        })(e, t);\n      }\n\n      function p(e, t) {\n        if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n      }\n\n      function v(e, t) {\n        for (var r = 0; r < t.length; r++) {\n          var n = t[r];\n          n.enumerable = n.enumerable || !1, n.configurable = !0, \"value\" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);\n        }\n      }\n\n      function y(e, t, r) {\n        return t && v(e.prototype, t), r && v(e, r), e;\n      }\n\n      var m = function (e) {\n        function t(e) {\n          var r;\n          if (p(this, t), (r = c(this, h(t).call(this))).defaultParams = {\n            audioContext: null,\n            audioScriptProcessor: null,\n            audioRate: 1,\n            autoCenter: !0,\n            backend: \"WebAudio\",\n            backgroundColor: null,\n            barHeight: 1,\n            barGap: null,\n            container: null,\n            cursorColor: \"#333\",\n            cursorWidth: 1,\n            dragSelection: !0,\n            duration: null,\n            fillParent: !0,\n            forceDecode: !1,\n            height: 128,\n            hideScrollbar: !1,\n            interact: !0,\n            loopSelection: !0,\n            maxCanvasWidth: 4e3,\n            mediaContainer: null,\n            mediaControls: !1,\n            mediaType: \"audio\",\n            minPxPerSec: 20,\n            normalize: !1,\n            partialRender: !1,\n            pixelRatio: window.devicePixelRatio || screen.deviceXDPI / screen.logicalXDPI,\n            plugins: [],\n            progressColor: \"#555\",\n            removeMediaElementOnDestroy: !0,\n            renderer: i.default,\n            responsive: !1,\n            rtl: !1,\n            scrollParent: !1,\n            skipLength: 2,\n            splitChannels: !1,\n            waveColor: \"#999\",\n            xhr: {}\n          }, r.backends = {\n            MediaElement: s.default,\n            WebAudio: a.default\n          }, r.util = n, r.params = n.extend({}, r.defaultParams, e), r.container = \"string\" == typeof e.container ? document.querySelector(r.params.container) : r.params.container, !r.container) throw new Error(\"Container element not found\");\n          if (null == r.params.mediaContainer ? r.mediaContainer = r.container : \"string\" == typeof r.params.mediaContainer ? r.mediaContainer = document.querySelector(r.params.mediaContainer) : r.mediaContainer = r.params.mediaContainer, !r.mediaContainer) throw new Error(\"Media Container element not found\");\n          if (r.params.maxCanvasWidth <= 1) throw new Error(\"maxCanvasWidth must be greater than 1\");\n          if (r.params.maxCanvasWidth % 2 == 1) throw new Error(\"maxCanvasWidth must be an even number\");\n          if (!0 === r.params.rtl && n.style(r.container, {\n            transform: \"rotateY(180deg)\"\n          }), r.params.backgroundColor && r.setBackgroundColor(r.params.backgroundColor), r.savedVolume = 0, r.isMuted = !1, r.tmpEvents = [], r.currentAjax = null, r.arraybuffer = null, r.drawer = null, r.backend = null, r.peakCache = null, \"function\" != typeof r.params.renderer) throw new Error(\"Renderer parameter is invalid\");\n          r.Drawer = r.params.renderer, r.Backend = r.backends[r.params.backend], r.initialisedPluginList = {}, r.isDestroyed = !1, r.isReady = !1;\n          var o = 0;\n          return r._onResize = n.debounce(function () {\n            o == r.drawer.wrapper.clientWidth || r.params.scrollParent || (o = r.drawer.wrapper.clientWidth, r.drawer.fireEvent(\"redraw\"));\n          }, \"number\" == typeof r.params.responsive ? r.params.responsive : 100), c(r, f(r));\n        }\n\n        return function (e, t) {\n          if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function\");\n          e.prototype = Object.create(t && t.prototype, {\n            constructor: {\n              value: e,\n              writable: !0,\n              configurable: !0\n            }\n          }), t && d(e, t);\n        }(t, n.Observer), y(t, null, [{\n          key: \"create\",\n          value: function (e) {\n            return new t(e).init();\n          }\n        }]), y(t, [{\n          key: \"init\",\n          value: function () {\n            return this.registerPlugins(this.params.plugins), this.createDrawer(), this.createBackend(), this.createPeakCache(), this;\n          }\n        }, {\n          key: \"registerPlugins\",\n          value: function (e) {\n            var t = this;\n            return e.forEach(function (e) {\n              return t.addPlugin(e);\n            }), e.forEach(function (e) {\n              e.deferInit || t.initPlugin(e.name);\n            }), this.fireEvent(\"plugins-registered\", e), this;\n          }\n        }, {\n          key: \"addPlugin\",\n          value: function (e) {\n            var t = this;\n            if (!e.name) throw new Error(\"Plugin does not have a name!\");\n            if (!e.instance) throw new Error(\"Plugin \".concat(e.name, \" does not have an instance property!\"));\n            e.staticProps && Object.keys(e.staticProps).forEach(function (r) {\n              t[r] = e.staticProps[r];\n            });\n            var r = e.instance;\n            return Object.getOwnPropertyNames(n.Observer.prototype).forEach(function (e) {\n              r.prototype[e] = n.Observer.prototype[e];\n            }), this[e.name] = new r(e.params || {}, this), this.fireEvent(\"plugin-added\", e.name), this;\n          }\n        }, {\n          key: \"initPlugin\",\n          value: function (e) {\n            if (!this[e]) throw new Error(\"Plugin \".concat(e, \" has not been added yet!\"));\n            return this.initialisedPluginList[e] && this.destroyPlugin(e), this[e].init(), this.initialisedPluginList[e] = !0, this.fireEvent(\"plugin-initialised\", e), this;\n          }\n        }, {\n          key: \"destroyPlugin\",\n          value: function (e) {\n            if (!this[e]) throw new Error(\"Plugin \".concat(e, \" has not been added yet and cannot be destroyed!\"));\n            if (!this.initialisedPluginList[e]) throw new Error(\"Plugin \".concat(e, \" is not active and cannot be destroyed!\"));\n            if (\"function\" != typeof this[e].destroy) throw new Error(\"Plugin \".concat(e, \" does not have a destroy function!\"));\n            return this[e].destroy(), delete this.initialisedPluginList[e], this.fireEvent(\"plugin-destroyed\", e), this;\n          }\n        }, {\n          key: \"destroyAllPlugins\",\n          value: function () {\n            var e = this;\n            Object.keys(this.initialisedPluginList).forEach(function (t) {\n              return e.destroyPlugin(t);\n            });\n          }\n        }, {\n          key: \"createDrawer\",\n          value: function () {\n            var e = this;\n            this.drawer = new this.Drawer(this.container, this.params), this.drawer.init(), this.fireEvent(\"drawer-created\", this.drawer), !1 !== this.params.responsive && (window.addEventListener(\"resize\", this._onResize, !0), window.addEventListener(\"orientationchange\", this._onResize, !0)), this.drawer.on(\"redraw\", function () {\n              e.drawBuffer(), e.drawer.progress(e.backend.getPlayedPercents());\n            }), this.drawer.on(\"click\", function (t, r) {\n              setTimeout(function () {\n                return e.seekTo(r);\n              }, 0);\n            }), this.drawer.on(\"scroll\", function (t) {\n              e.params.partialRender && e.drawBuffer(), e.fireEvent(\"scroll\", t);\n            });\n          }\n        }, {\n          key: \"createBackend\",\n          value: function () {\n            var e = this;\n            this.backend && this.backend.destroy(), \"AudioElement\" == this.params.backend && (this.params.backend = \"MediaElement\"), \"WebAudio\" != this.params.backend || this.Backend.prototype.supportsWebAudio.call(null) || (this.params.backend = \"MediaElement\"), this.backend = new this.Backend(this.params), this.backend.init(), this.fireEvent(\"backend-created\", this.backend), this.backend.on(\"finish\", function () {\n              e.drawer.progress(e.backend.getPlayedPercents()), e.fireEvent(\"finish\");\n            }), this.backend.on(\"play\", function () {\n              return e.fireEvent(\"play\");\n            }), this.backend.on(\"pause\", function () {\n              return e.fireEvent(\"pause\");\n            }), this.backend.on(\"audioprocess\", function (t) {\n              e.drawer.progress(e.backend.getPlayedPercents()), e.fireEvent(\"audioprocess\", t);\n            });\n          }\n        }, {\n          key: \"createPeakCache\",\n          value: function () {\n            this.params.partialRender && (this.peakCache = new o.default());\n          }\n        }, {\n          key: \"getDuration\",\n          value: function () {\n            return this.backend.getDuration();\n          }\n        }, {\n          key: \"getCurrentTime\",\n          value: function () {\n            return this.backend.getCurrentTime();\n          }\n        }, {\n          key: \"setCurrentTime\",\n          value: function (e) {\n            e >= this.getDuration() ? this.seekTo(1) : this.seekTo(e / this.getDuration());\n          }\n        }, {\n          key: \"play\",\n          value: function (e, t) {\n            var r = this;\n            return this.fireEvent(\"interaction\", function () {\n              return r.play(e, t);\n            }), this.backend.play(e, t);\n          }\n        }, {\n          key: \"pause\",\n          value: function () {\n            if (!this.backend.isPaused()) return this.backend.pause();\n          }\n        }, {\n          key: \"playPause\",\n          value: function () {\n            return this.backend.isPaused() ? this.play() : this.pause();\n          }\n        }, {\n          key: \"isPlaying\",\n          value: function () {\n            return !this.backend.isPaused();\n          }\n        }, {\n          key: \"skipBackward\",\n          value: function (e) {\n            this.skip(-e || -this.params.skipLength);\n          }\n        }, {\n          key: \"skipForward\",\n          value: function (e) {\n            this.skip(e || this.params.skipLength);\n          }\n        }, {\n          key: \"skip\",\n          value: function (e) {\n            var t = this.getDuration() || 1,\n                r = this.getCurrentTime() || 0;\n            r = Math.max(0, Math.min(t, r + (e || 0))), this.seekAndCenter(r / t);\n          }\n        }, {\n          key: \"seekAndCenter\",\n          value: function (e) {\n            this.seekTo(e), this.drawer.recenter(e);\n          }\n        }, {\n          key: \"seekTo\",\n          value: function (e) {\n            var t = this;\n            if (\"number\" != typeof e || !isFinite(e) || e < 0 || e > 1) return console.error(\"Error calling wavesurfer.seekTo, parameter must be a number between 0 and 1!\");\n            this.fireEvent(\"interaction\", function () {\n              return t.seekTo(e);\n            });\n            var r = this.backend.isPaused();\n            r || this.backend.pause();\n            var n = this.params.scrollParent;\n            this.params.scrollParent = !1, this.backend.seekTo(e * this.getDuration()), this.drawer.progress(e), r || this.backend.play(), this.params.scrollParent = n, this.fireEvent(\"seek\", e);\n          }\n        }, {\n          key: \"stop\",\n          value: function () {\n            this.pause(), this.seekTo(0), this.drawer.progress(0);\n          }\n        }, {\n          key: \"setSinkId\",\n          value: function (e) {\n            return this.backend.setSinkId(e);\n          }\n        }, {\n          key: \"setVolume\",\n          value: function (e) {\n            this.backend.setVolume(e), this.fireEvent(\"volume\", e);\n          }\n        }, {\n          key: \"getVolume\",\n          value: function () {\n            return this.backend.getVolume();\n          }\n        }, {\n          key: \"setPlaybackRate\",\n          value: function (e) {\n            this.backend.setPlaybackRate(e);\n          }\n        }, {\n          key: \"getPlaybackRate\",\n          value: function () {\n            return this.backend.getPlaybackRate();\n          }\n        }, {\n          key: \"toggleMute\",\n          value: function () {\n            this.setMute(!this.isMuted);\n          }\n        }, {\n          key: \"setMute\",\n          value: function (e) {\n            e !== this.isMuted ? (e ? (this.savedVolume = this.backend.getVolume(), this.backend.setVolume(0), this.isMuted = !0, this.fireEvent(\"volume\", 0)) : (this.backend.setVolume(this.savedVolume), this.isMuted = !1, this.fireEvent(\"volume\", this.savedVolume)), this.fireEvent(\"mute\", this.isMuted)) : this.fireEvent(\"mute\", this.isMuted);\n          }\n        }, {\n          key: \"getMute\",\n          value: function () {\n            return this.isMuted;\n          }\n        }, {\n          key: \"isReady\",\n          value: function () {\n            return this.isReady;\n          }\n        }, {\n          key: \"getFilters\",\n          value: function () {\n            return this.backend.filters || [];\n          }\n        }, {\n          key: \"toggleScroll\",\n          value: function () {\n            this.params.scrollParent = !this.params.scrollParent, this.drawBuffer();\n          }\n        }, {\n          key: \"toggleInteraction\",\n          value: function () {\n            this.params.interact = !this.params.interact;\n          }\n        }, {\n          key: \"getWaveColor\",\n          value: function () {\n            return this.params.waveColor;\n          }\n        }, {\n          key: \"setWaveColor\",\n          value: function (e) {\n            this.params.waveColor = e, this.drawBuffer();\n          }\n        }, {\n          key: \"getProgressColor\",\n          value: function () {\n            return this.params.progressColor;\n          }\n        }, {\n          key: \"setProgressColor\",\n          value: function (e) {\n            this.params.progressColor = e, this.drawBuffer();\n          }\n        }, {\n          key: \"getBackgroundColor\",\n          value: function () {\n            return this.params.backgroundColor;\n          }\n        }, {\n          key: \"setBackgroundColor\",\n          value: function (e) {\n            this.params.backgroundColor = e, n.style(this.container, {\n              background: this.params.backgroundColor\n            });\n          }\n        }, {\n          key: \"getCursorColor\",\n          value: function () {\n            return this.params.cursorColor;\n          }\n        }, {\n          key: \"setCursorColor\",\n          value: function (e) {\n            this.params.cursorColor = e, this.drawer.updateCursor();\n          }\n        }, {\n          key: \"getHeight\",\n          value: function () {\n            return this.params.height;\n          }\n        }, {\n          key: \"setHeight\",\n          value: function (e) {\n            this.params.height = e, this.drawer.setHeight(e * this.params.pixelRatio), this.drawBuffer();\n          }\n        }, {\n          key: \"drawBuffer\",\n          value: function () {\n            var e,\n                t = Math.round(this.getDuration() * this.params.minPxPerSec * this.params.pixelRatio),\n                r = this.drawer.getWidth(),\n                n = t,\n                i = 0,\n                a = Math.max(i + r, n);\n\n            if (this.params.fillParent && (!this.params.scrollParent || t < r) && (i = 0, a = n = r), this.params.partialRender) {\n              var s,\n                  o = this.peakCache.addRangeToPeakCache(n, i, a);\n\n              for (s = 0; s < o.length; s++) e = this.backend.getPeaks(n, o[s][0], o[s][1]), this.drawer.drawPeaks(e, n, o[s][0], o[s][1]);\n            } else e = this.backend.getPeaks(n, i, a), this.drawer.drawPeaks(e, n, i, a);\n\n            this.fireEvent(\"redraw\", e, n);\n          }\n        }, {\n          key: \"zoom\",\n          value: function (e) {\n            e ? (this.params.minPxPerSec = e, this.params.scrollParent = !0) : (this.params.minPxPerSec = this.defaultParams.minPxPerSec, this.params.scrollParent = !1), this.drawBuffer(), this.drawer.progress(this.backend.getPlayedPercents()), this.drawer.recenter(this.getCurrentTime() / this.getDuration()), this.fireEvent(\"zoom\", e);\n          }\n        }, {\n          key: \"loadArrayBuffer\",\n          value: function (e) {\n            var t = this;\n            this.decodeArrayBuffer(e, function (e) {\n              t.isDestroyed || t.loadDecodedBuffer(e);\n            });\n          }\n        }, {\n          key: \"loadDecodedBuffer\",\n          value: function (e) {\n            this.backend.load(e), this.drawBuffer(), this.fireEvent(\"ready\"), this.isReady = !0;\n          }\n        }, {\n          key: \"loadBlob\",\n          value: function (e) {\n            var t = this,\n                r = new FileReader();\n            r.addEventListener(\"progress\", function (e) {\n              return t.onProgress(e);\n            }), r.addEventListener(\"load\", function (e) {\n              return t.loadArrayBuffer(e.target.result);\n            }), r.addEventListener(\"error\", function () {\n              return t.fireEvent(\"error\", \"Error reading file\");\n            }), r.readAsArrayBuffer(e), this.empty();\n          }\n        }, {\n          key: \"load\",\n          value: function (e, t, r, n) {\n            if (this.empty(), r) {\n              var i = {\n                \"Preload is not 'auto', 'none' or 'metadata'\": -1 === [\"auto\", \"metadata\", \"none\"].indexOf(r),\n                \"Peaks are not provided\": !t,\n                \"Backend is not of type MediaElement\": \"MediaElement\" !== this.params.backend,\n                \"Url is not of type string\": \"string\" != typeof e\n              },\n                  a = Object.keys(i).filter(function (e) {\n                return i[e];\n              });\n              a.length && (console.warn(\"Preload parameter of wavesurfer.load will be ignored because:\\n\\t- \" + a.join(\"\\n\\t- \")), r = null);\n            }\n\n            switch (this.params.backend) {\n              case \"WebAudio\":\n                return this.loadBuffer(e, t, n);\n\n              case \"MediaElement\":\n                return this.loadMediaElement(e, t, r, n);\n            }\n          }\n        }, {\n          key: \"loadBuffer\",\n          value: function (e, t, r) {\n            var n = this,\n                i = function (t) {\n              return t && n.tmpEvents.push(n.once(\"ready\", t)), n.getArrayBuffer(e, function (e) {\n                return n.loadArrayBuffer(e);\n              });\n            };\n\n            if (!t) return i();\n            this.backend.setPeaks(t, r), this.drawBuffer(), this.tmpEvents.push(this.once(\"interaction\", i));\n          }\n        }, {\n          key: \"loadMediaElement\",\n          value: function (e, t, r, n) {\n            var i = this,\n                a = e;\n            if (\"string\" == typeof e) this.backend.load(a, this.mediaContainer, t, r);else {\n              var s = e;\n              this.backend.loadElt(s, t), a = s.src;\n            }\n            this.tmpEvents.push(this.backend.once(\"canplay\", function () {\n              i.drawBuffer(), i.fireEvent(\"ready\"), i.isReady = !0;\n            }), this.backend.once(\"error\", function (e) {\n              return i.fireEvent(\"error\", e);\n            })), t && this.backend.setPeaks(t, n), t && !this.params.forceDecode || !this.backend.supportsWebAudio() || this.getArrayBuffer(a, function (e) {\n              i.decodeArrayBuffer(e, function (e) {\n                i.backend.buffer = e, i.backend.setPeaks(null), i.drawBuffer(), i.fireEvent(\"waveform-ready\");\n              });\n            });\n          }\n        }, {\n          key: \"decodeArrayBuffer\",\n          value: function (e, t) {\n            var r = this;\n            this.arraybuffer = e, this.backend.decodeArrayBuffer(e, function (n) {\n              r.isDestroyed || r.arraybuffer != e || (t(n), r.arraybuffer = null);\n            }, function () {\n              return r.fireEvent(\"error\", \"Error decoding audiobuffer\");\n            });\n          }\n        }, {\n          key: \"getArrayBuffer\",\n          value: function (e, t) {\n            var r = this,\n                i = n.ajax({\n              url: e,\n              responseType: \"arraybuffer\",\n              xhr: this.params.xhr\n            });\n            return this.currentAjax = i, this.tmpEvents.push(i.on(\"progress\", function (e) {\n              r.onProgress(e);\n            }), i.on(\"success\", function (e, n) {\n              t(e), r.currentAjax = null;\n            }), i.on(\"error\", function (e) {\n              r.fireEvent(\"error\", \"XHR error: \" + e.target.statusText), r.currentAjax = null;\n            })), i;\n          }\n        }, {\n          key: \"onProgress\",\n          value: function (e) {\n            var t;\n            t = e.lengthComputable ? e.loaded / e.total : e.loaded / (e.loaded + 1e6), this.fireEvent(\"loading\", Math.round(100 * t), e.target);\n          }\n        }, {\n          key: \"exportPCM\",\n          value: function (e, t, r, n) {\n            e = e || 1024, n = n || 0, t = t || 1e4, r = r || !1;\n            var i = this.backend.getPeaks(e, n),\n                a = [].map.call(i, function (e) {\n              return Math.round(e * t) / t;\n            }),\n                s = JSON.stringify(a);\n            return r || window.open(\"data:application/json;charset=utf-8,\" + encodeURIComponent(s)), s;\n          }\n        }, {\n          key: \"exportImage\",\n          value: function (e, t) {\n            return e || (e = \"image/png\"), t || (t = 1), this.drawer.getImage(e, t);\n          }\n        }, {\n          key: \"cancelAjax\",\n          value: function () {\n            this.currentAjax && (this.currentAjax.xhr.abort(), this.currentAjax = null);\n          }\n        }, {\n          key: \"clearTmpEvents\",\n          value: function () {\n            this.tmpEvents.forEach(function (e) {\n              return e.un();\n            });\n          }\n        }, {\n          key: \"empty\",\n          value: function () {\n            this.backend.isPaused() || (this.stop(), this.backend.disconnectSource()), this.isReady = !1, this.cancelAjax(), this.clearTmpEvents(), this.drawer.progress(0), this.drawer.setWidth(0), this.drawer.drawPeaks({\n              length: this.drawer.getWidth()\n            }, 0);\n          }\n        }, {\n          key: \"destroy\",\n          value: function () {\n            this.destroyAllPlugins(), this.fireEvent(\"destroy\"), this.cancelAjax(), this.clearTmpEvents(), this.unAll(), !1 !== this.params.responsive && (window.removeEventListener(\"resize\", this._onResize, !0), window.removeEventListener(\"orientationchange\", this._onResize, !0)), this.backend.destroy(), this.drawer.destroy(), this.isDestroyed = !0, this.isReady = !1, this.arraybuffer = null;\n          }\n        }]), t;\n      }();\n\n      t.default = m, m.VERSION = \"2.2.1\", m.util = n, e.exports = t.default;\n    }, function (e, t, r) {\n      Object.defineProperty(t, \"__esModule\", {\n        value: !0\n      }), t.default = function (e) {\n        var t = new i.default(),\n            r = new XMLHttpRequest(),\n            n = !1;\n        r.open(e.method || \"GET\", e.url, !0), r.responseType = e.responseType || \"json\", e.xhr && (e.xhr.requestHeaders && e.xhr.requestHeaders.forEach(function (e) {\n          r.setRequestHeader(e.key, e.value);\n        }), e.xhr.withCredentials && (r.withCredentials = !0));\n        return r.addEventListener(\"progress\", function (e) {\n          t.fireEvent(\"progress\", e), e.lengthComputable && e.loaded == e.total && (n = !0);\n        }), r.addEventListener(\"load\", function (e) {\n          n || t.fireEvent(\"progress\", e), t.fireEvent(\"load\", e), 200 == r.status || 206 == r.status ? t.fireEvent(\"success\", r.response, e) : t.fireEvent(\"error\", e);\n        }), r.addEventListener(\"error\", function (e) {\n          return t.fireEvent(\"error\", e);\n        }), r.send(), t.xhr = r, t;\n      };\n      var n,\n          i = (n = r(1)) && n.__esModule ? n : {\n        default: n\n      };\n      e.exports = t.default;\n    }, function (e, t, r) {\n      Object.defineProperty(t, \"__esModule\", {\n        value: !0\n      }), t.default = function () {\n        return \"wavesurfer_\" + Math.random().toString(32).substring(2);\n      }, e.exports = t.default;\n    }, function (e, t, r) {\n      Object.defineProperty(t, \"__esModule\", {\n        value: !0\n      }), t.default = function (e) {\n        var t = -1 / 0;\n        return Object.keys(e).forEach(function (r) {\n          e[r] > t && (t = e[r]);\n        }), t;\n      }, e.exports = t.default;\n    }, function (e, t, r) {\n      Object.defineProperty(t, \"__esModule\", {\n        value: !0\n      }), t.default = function (e) {\n        var t = Number(1 / 0);\n        return Object.keys(e).forEach(function (r) {\n          e[r] < t && (t = e[r]);\n        }), t;\n      }, e.exports = t.default;\n    }, function (e, t, r) {\n      Object.defineProperty(t, \"__esModule\", {\n        value: !0\n      }), t.default = function (e) {\n        for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++) r[n - 1] = arguments[n];\n\n        return r.forEach(function (t) {\n          Object.keys(t).forEach(function (r) {\n            e[r] = t[r];\n          });\n        }), e;\n      }, e.exports = t.default;\n    }, function (e, t, r) {\n      Object.defineProperty(t, \"__esModule\", {\n        value: !0\n      }), t.default = function (e, t) {\n        return Object.keys(t).forEach(function (r) {\n          e.style[r] !== t[r] && (e.style[r] = t[r]);\n        }), e;\n      }, e.exports = t.default;\n    }, function (e, t, r) {\n      Object.defineProperty(t, \"__esModule\", {\n        value: !0\n      }), t.default = function (e) {\n        return function () {\n          for (var t = arguments.length, r = new Array(t), n = 0; n < t; n++) r[n] = arguments[n];\n\n          return (0, i.default)(function () {\n            return e.apply(void 0, r);\n          });\n        };\n      };\n      var n,\n          i = (n = r(2)) && n.__esModule ? n : {\n        default: n\n      };\n      e.exports = t.default;\n    }, function (e, t) {\n      function r(e, t, r) {\n        var n, i, a, s, o;\n\n        function u() {\n          var l = Date.now() - s;\n          l < t && l >= 0 ? n = setTimeout(u, t - l) : (n = null, r || (o = e.apply(a, i), a = i = null));\n        }\n\n        null == t && (t = 100);\n\n        var l = function () {\n          a = this, i = arguments, s = Date.now();\n          var l = r && !n;\n          return n || (n = setTimeout(u, t)), l && (o = e.apply(a, i), a = i = null), o;\n        };\n\n        return l.clear = function () {\n          n && (clearTimeout(n), n = null);\n        }, l.flush = function () {\n          n && (o = e.apply(a, i), a = i = null, clearTimeout(n), n = null);\n        }, l;\n      }\n\n      r.debounce = r, e.exports = r;\n    }, function (e, t, r) {\n      function n(e) {\n        e.stopPropagation(), document.body.removeEventListener(\"click\", n, !0);\n      }\n\n      Object.defineProperty(t, \"__esModule\", {\n        value: !0\n      }), t.default = function (e) {\n        document.body.addEventListener(\"click\", n, !0);\n      }, e.exports = t.default;\n    }, function (e, t, r) {\n      Object.defineProperty(t, \"__esModule\", {\n        value: !0\n      }), t.default = void 0;\n\n      var n,\n          i = (n = r(15)) && n.__esModule ? n : {\n        default: n\n      },\n          a = function (e) {\n        if (e && e.__esModule) return e;\n        var t = {};\n        if (null != e) for (var r in e) if (Object.prototype.hasOwnProperty.call(e, r)) {\n          var n = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(e, r) : {};\n          n.get || n.set ? Object.defineProperty(t, r, n) : t[r] = e[r];\n        }\n        return t.default = e, t;\n      }(r(0));\n\n      function s(e) {\n        return (s = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (e) {\n          return typeof e;\n        } : function (e) {\n          return e && \"function\" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? \"symbol\" : typeof e;\n        })(e);\n      }\n\n      function o(e, t) {\n        for (var r = 0; r < t.length; r++) {\n          var n = t[r];\n          n.enumerable = n.enumerable || !1, n.configurable = !0, \"value\" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);\n        }\n      }\n\n      function u(e, t) {\n        return !t || \"object\" !== s(t) && \"function\" != typeof t ? function (e) {\n          if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n          return e;\n        }(e) : t;\n      }\n\n      function l(e) {\n        return (l = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) {\n          return e.__proto__ || Object.getPrototypeOf(e);\n        })(e);\n      }\n\n      function c(e, t) {\n        return (c = Object.setPrototypeOf || function (e, t) {\n          return e.__proto__ = t, e;\n        })(e, t);\n      }\n\n      var h = function (e) {\n        function t(e, r) {\n          var n;\n          return function (e, t) {\n            if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n          }(this, t), (n = u(this, l(t).call(this, e, r))).maxCanvasWidth = r.maxCanvasWidth, n.maxCanvasElementWidth = Math.round(r.maxCanvasWidth / r.pixelRatio), n.hasProgressCanvas = r.waveColor != r.progressColor, n.halfPixel = .5 / r.pixelRatio, n.canvases = [], n.progressWave = null, n;\n        }\n\n        var r, n;\n        return function (e, t) {\n          if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function\");\n          e.prototype = Object.create(t && t.prototype, {\n            constructor: {\n              value: e,\n              writable: !0,\n              configurable: !0\n            }\n          }), t && c(e, t);\n        }(t, i.default), r = t, (n = [{\n          key: \"init\",\n          value: function () {\n            this.createWrapper(), this.createElements();\n          }\n        }, {\n          key: \"createElements\",\n          value: function () {\n            this.progressWave = this.wrapper.appendChild(this.style(document.createElement(\"wave\"), {\n              position: \"absolute\",\n              zIndex: 3,\n              left: 0,\n              top: 0,\n              bottom: 0,\n              overflow: \"hidden\",\n              width: \"0\",\n              display: \"none\",\n              boxSizing: \"border-box\",\n              borderRightStyle: \"solid\",\n              pointerEvents: \"none\"\n            })), this.addCanvas(), this.updateCursor();\n          }\n        }, {\n          key: \"updateCursor\",\n          value: function () {\n            this.style(this.progressWave, {\n              borderRightWidth: this.params.cursorWidth + \"px\",\n              borderRightColor: this.params.cursorColor\n            });\n          }\n        }, {\n          key: \"updateSize\",\n          value: function () {\n            for (var e = this, t = Math.round(this.width / this.params.pixelRatio), r = Math.ceil(t / (this.maxCanvasElementWidth + 2)); this.canvases.length < r;) this.addCanvas();\n\n            for (; this.canvases.length > r;) this.removeCanvas();\n\n            this.canvases.forEach(function (t, r) {\n              var n = e.maxCanvasWidth + 2 * Math.ceil(e.params.pixelRatio / 2);\n              r == e.canvases.length - 1 && (n = e.width - e.maxCanvasWidth * (e.canvases.length - 1)), e.updateDimensions(t, n, e.height), e.clearWaveForEntry(t);\n            });\n          }\n        }, {\n          key: \"addCanvas\",\n          value: function () {\n            var e = {},\n                t = this.maxCanvasElementWidth * this.canvases.length;\n            e.wave = this.wrapper.appendChild(this.style(document.createElement(\"canvas\"), {\n              position: \"absolute\",\n              zIndex: 2,\n              left: t + \"px\",\n              top: 0,\n              bottom: 0,\n              height: \"100%\",\n              pointerEvents: \"none\"\n            })), e.waveCtx = e.wave.getContext(\"2d\"), this.hasProgressCanvas && (e.progress = this.progressWave.appendChild(this.style(document.createElement(\"canvas\"), {\n              position: \"absolute\",\n              left: t + \"px\",\n              top: 0,\n              bottom: 0,\n              height: \"100%\"\n            })), e.progressCtx = e.progress.getContext(\"2d\")), this.canvases.push(e);\n          }\n        }, {\n          key: \"removeCanvas\",\n          value: function () {\n            var e = this.canvases.pop();\n            e.wave.parentElement.removeChild(e.wave), this.hasProgressCanvas && e.progress.parentElement.removeChild(e.progress);\n          }\n        }, {\n          key: \"updateDimensions\",\n          value: function (e, t, r) {\n            var n = Math.round(t / this.params.pixelRatio),\n                i = Math.round(this.width / this.params.pixelRatio);\n            e.start = e.waveCtx.canvas.offsetLeft / i || 0, e.end = e.start + n / i, e.waveCtx.canvas.width = t, e.waveCtx.canvas.height = r, this.style(e.waveCtx.canvas, {\n              width: n + \"px\"\n            }), this.style(this.progressWave, {\n              display: \"block\"\n            }), this.hasProgressCanvas && (e.progressCtx.canvas.width = t, e.progressCtx.canvas.height = r, this.style(e.progressCtx.canvas, {\n              width: n + \"px\"\n            }));\n          }\n        }, {\n          key: \"clearWave\",\n          value: function () {\n            var e = this;\n            this.canvases.forEach(function (t) {\n              return e.clearWaveForEntry(t);\n            });\n          }\n        }, {\n          key: \"clearWaveForEntry\",\n          value: function (e) {\n            e.waveCtx.clearRect(0, 0, e.waveCtx.canvas.width, e.waveCtx.canvas.height), this.hasProgressCanvas && e.progressCtx.clearRect(0, 0, e.progressCtx.canvas.width, e.progressCtx.canvas.height);\n          }\n        }, {\n          key: \"drawBars\",\n          value: function (e, t, r, n) {\n            var i = this;\n            return this.prepareDraw(e, t, r, n, function (e) {\n              var t = e.absmax,\n                  a = e.hasMinVals,\n                  s = (e.height, e.offsetY),\n                  o = e.halfH,\n                  u = e.peaks;\n\n              if (void 0 !== r) {\n                var l,\n                    c = a ? 2 : 1,\n                    h = u.length / c,\n                    f = i.params.barWidth * i.params.pixelRatio,\n                    d = f + (null === i.params.barGap ? Math.max(i.params.pixelRatio, ~~(f / 2)) : Math.max(i.params.pixelRatio, i.params.barGap * i.params.pixelRatio)),\n                    p = h / i.width,\n                    v = n;\n\n                for (l = r; l < v; l += d) {\n                  var y = u[Math.floor(l * p * c)] || 0,\n                      m = Math.round(y / t * o);\n                  i.fillRect(l + i.halfPixel, o - m + s, f + i.halfPixel, 2 * m);\n                }\n              }\n            });\n          }\n        }, {\n          key: \"drawWave\",\n          value: function (e, t, r, n) {\n            var i = this;\n            return this.prepareDraw(e, t, r, n, function (e) {\n              var t = e.absmax,\n                  a = e.hasMinVals,\n                  s = (e.height, e.offsetY),\n                  o = e.halfH,\n                  u = e.peaks;\n\n              if (!a) {\n                var l,\n                    c = [],\n                    h = u.length;\n\n                for (l = 0; l < h; l++) c[2 * l] = u[l], c[2 * l + 1] = -u[l];\n\n                u = c;\n              }\n\n              void 0 !== r && i.drawLine(u, t, o, s, r, n), i.fillRect(0, o + s - i.halfPixel, i.width, i.halfPixel);\n            });\n          }\n        }, {\n          key: \"drawLine\",\n          value: function (e, t, r, n, i, a) {\n            var s = this;\n            this.canvases.forEach(function (o) {\n              s.setFillStyles(o), s.drawLineToContext(o, o.waveCtx, e, t, r, n, i, a), s.drawLineToContext(o, o.progressCtx, e, t, r, n, i, a);\n            });\n          }\n        }, {\n          key: \"drawLineToContext\",\n          value: function (e, t, r, n, i, a, s, o) {\n            if (t) {\n              var u,\n                  l,\n                  c = r.length / 2,\n                  h = Math.round(c * e.start),\n                  f = h,\n                  d = Math.round(c * e.end) + 1,\n                  p = e.progress.width / (d - f - 1),\n                  v = i + a,\n                  y = n / i;\n\n              for (t.beginPath(), t.moveTo((f - h) * p, v), t.lineTo((f - h) * p, v - Math.round((r[2 * f] || 0) / y)), u = f; u < d; u++) {\n                var m = r[2 * u] || 0,\n                    b = Math.round(m / y);\n                t.lineTo((u - h) * p + this.halfPixel, v - b);\n              }\n\n              for (l = d - 1; l >= f; l--) {\n                var g = r[2 * l + 1] || 0,\n                    k = Math.round(g / y);\n                t.lineTo((l - h) * p + this.halfPixel, v - k);\n              }\n\n              t.lineTo((f - h) * p, v - Math.round((r[2 * f + 1] || 0) / y)), t.closePath(), t.fill();\n            }\n          }\n        }, {\n          key: \"fillRect\",\n          value: function (e, t, r, n) {\n            var i,\n                a = Math.floor(e / this.maxCanvasWidth),\n                s = Math.min(Math.ceil((e + r) / this.maxCanvasWidth) + 1, this.canvases.length);\n\n            for (i = a; i < s; i++) {\n              var o = this.canvases[i],\n                  u = i * this.maxCanvasWidth,\n                  l = {\n                x1: Math.max(e, i * this.maxCanvasWidth),\n                y1: t,\n                x2: Math.min(e + r, i * this.maxCanvasWidth + o.waveCtx.canvas.width),\n                y2: t + n\n              };\n              l.x1 < l.x2 && (this.setFillStyles(o), this.fillRectToContext(o.waveCtx, l.x1 - u, l.y1, l.x2 - l.x1, l.y2 - l.y1), this.fillRectToContext(o.progressCtx, l.x1 - u, l.y1, l.x2 - l.x1, l.y2 - l.y1));\n            }\n          }\n        }, {\n          key: \"prepareDraw\",\n          value: function (e, t, r, n, i) {\n            var s = this;\n            return a.frame(function () {\n              if (e[0] instanceof Array) {\n                var o = e;\n                if (s.params.splitChannels) return s.setHeight(o.length * s.params.height * s.params.pixelRatio), o.forEach(function (e, t) {\n                  return s.prepareDraw(e, t, r, n, i);\n                });\n                e = o[0];\n              }\n\n              var u = 1 / s.params.barHeight;\n\n              if (s.params.normalize) {\n                var l = a.max(e),\n                    c = a.min(e);\n                u = -c > l ? -c : l;\n              }\n\n              var h = [].some.call(e, function (e) {\n                return e < 0;\n              }),\n                  f = s.params.height * s.params.pixelRatio;\n              return i({\n                absmax: u,\n                hasMinVals: h,\n                height: f,\n                offsetY: f * t || 0,\n                halfH: f / 2,\n                peaks: e\n              });\n            })();\n          }\n        }, {\n          key: \"fillRectToContext\",\n          value: function (e, t, r, n, i) {\n            e && e.fillRect(t, r, n, i);\n          }\n        }, {\n          key: \"setFillStyles\",\n          value: function (e) {\n            e.waveCtx.fillStyle = this.params.waveColor, this.hasProgressCanvas && (e.progressCtx.fillStyle = this.params.progressColor);\n          }\n        }, {\n          key: \"getImage\",\n          value: function (e, t) {\n            var r = this.canvases.map(function (r) {\n              return r.wave.toDataURL(e, t);\n            });\n            return r.length > 1 ? r : r[0];\n          }\n        }, {\n          key: \"updateProgress\",\n          value: function (e) {\n            this.style(this.progressWave, {\n              width: e + \"px\"\n            });\n          }\n        }]) && o(r.prototype, n), t;\n      }();\n\n      t.default = h, e.exports = t.default;\n    }, function (e, t, r) {\n      Object.defineProperty(t, \"__esModule\", {\n        value: !0\n      }), t.default = void 0;\n\n      var n = function (e) {\n        if (e && e.__esModule) return e;\n        var t = {};\n        if (null != e) for (var r in e) if (Object.prototype.hasOwnProperty.call(e, r)) {\n          var n = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(e, r) : {};\n          n.get || n.set ? Object.defineProperty(t, r, n) : t[r] = e[r];\n        }\n        return t.default = e, t;\n      }(r(0));\n\n      function i(e) {\n        return (i = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (e) {\n          return typeof e;\n        } : function (e) {\n          return e && \"function\" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? \"symbol\" : typeof e;\n        })(e);\n      }\n\n      function a(e, t) {\n        for (var r = 0; r < t.length; r++) {\n          var n = t[r];\n          n.enumerable = n.enumerable || !1, n.configurable = !0, \"value\" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);\n        }\n      }\n\n      function s(e, t) {\n        return !t || \"object\" !== i(t) && \"function\" != typeof t ? function (e) {\n          if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n          return e;\n        }(e) : t;\n      }\n\n      function o(e) {\n        return (o = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) {\n          return e.__proto__ || Object.getPrototypeOf(e);\n        })(e);\n      }\n\n      function u(e, t) {\n        return (u = Object.setPrototypeOf || function (e, t) {\n          return e.__proto__ = t, e;\n        })(e, t);\n      }\n\n      var l = function (e) {\n        function t(e, r) {\n          var n;\n          return function (e, t) {\n            if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n          }(this, t), (n = s(this, o(t).call(this))).container = e, n.params = r, n.width = 0, n.height = r.height * n.params.pixelRatio, n.lastPos = 0, n.wrapper = null, n;\n        }\n\n        var r, i;\n        return function (e, t) {\n          if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function\");\n          e.prototype = Object.create(t && t.prototype, {\n            constructor: {\n              value: e,\n              writable: !0,\n              configurable: !0\n            }\n          }), t && u(e, t);\n        }(t, n.Observer), r = t, (i = [{\n          key: \"style\",\n          value: function (e, t) {\n            return n.style(e, t);\n          }\n        }, {\n          key: \"createWrapper\",\n          value: function () {\n            this.wrapper = this.container.appendChild(document.createElement(\"wave\")), this.style(this.wrapper, {\n              display: \"block\",\n              position: \"relative\",\n              userSelect: \"none\",\n              webkitUserSelect: \"none\",\n              height: this.params.height + \"px\"\n            }), (this.params.fillParent || this.params.scrollParent) && this.style(this.wrapper, {\n              width: \"100%\",\n              overflowX: this.params.hideScrollbar ? \"hidden\" : \"auto\",\n              overflowY: \"hidden\"\n            }), this.setupWrapperEvents();\n          }\n        }, {\n          key: \"handleEvent\",\n          value: function (e, t) {\n            !t && e.preventDefault();\n            var r,\n                n = e.targetTouches ? e.targetTouches[0].clientX : e.clientX,\n                i = this.wrapper.getBoundingClientRect(),\n                a = this.width,\n                s = this.getWidth();\n            return !this.params.fillParent && a < s ? (r = (this.params.rtl ? i.right - n : n - i.left) * (this.params.pixelRatio / a) || 0) > 1 && (r = 1) : r = ((this.params.rtl ? i.right - n : n - i.left) + this.wrapper.scrollLeft) / this.wrapper.scrollWidth || 0, r;\n          }\n        }, {\n          key: \"setupWrapperEvents\",\n          value: function () {\n            var e = this;\n            this.wrapper.addEventListener(\"click\", function (t) {\n              var r = e.wrapper.offsetHeight - e.wrapper.clientHeight;\n\n              if (0 != r) {\n                var n = e.wrapper.getBoundingClientRect();\n                if (t.clientY >= n.bottom - r) return;\n              }\n\n              e.params.interact && e.fireEvent(\"click\", t, e.handleEvent(t));\n            }), this.wrapper.addEventListener(\"scroll\", function (t) {\n              return e.fireEvent(\"scroll\", t);\n            });\n          }\n        }, {\n          key: \"drawPeaks\",\n          value: function (e, t, r, n) {\n            this.setWidth(t) || this.clearWave(), this.params.barWidth ? this.drawBars(e, 0, r, n) : this.drawWave(e, 0, r, n);\n          }\n        }, {\n          key: \"resetScroll\",\n          value: function () {\n            null !== this.wrapper && (this.wrapper.scrollLeft = 0);\n          }\n        }, {\n          key: \"recenter\",\n          value: function (e) {\n            var t = this.wrapper.scrollWidth * e;\n            this.recenterOnPosition(t, !0);\n          }\n        }, {\n          key: \"recenterOnPosition\",\n          value: function (e, t) {\n            var r = this.wrapper.scrollLeft,\n                n = ~~(this.wrapper.clientWidth / 2),\n                i = this.wrapper.scrollWidth - this.wrapper.clientWidth,\n                a = e - n,\n                s = a - r;\n\n            if (0 != i) {\n              if (!t && -n <= s && s < n) {\n                a = r + (s = Math.max(-5, Math.min(5, s)));\n              }\n\n              (a = Math.max(0, Math.min(i, a))) != r && (this.wrapper.scrollLeft = a);\n            }\n          }\n        }, {\n          key: \"getScrollX\",\n          value: function () {\n            var e = 0;\n\n            if (this.wrapper) {\n              var t = this.params.pixelRatio;\n\n              if (e = Math.round(this.wrapper.scrollLeft * t), this.params.scrollParent) {\n                var r = ~~(this.wrapper.scrollWidth * t - this.getWidth());\n                e = Math.min(r, Math.max(0, e));\n              }\n            }\n\n            return e;\n          }\n        }, {\n          key: \"getWidth\",\n          value: function () {\n            return Math.round(this.container.clientWidth * this.params.pixelRatio);\n          }\n        }, {\n          key: \"setWidth\",\n          value: function (e) {\n            return this.width != e && (this.width = e, this.params.fillParent || this.params.scrollParent ? this.style(this.wrapper, {\n              width: \"\"\n            }) : this.style(this.wrapper, {\n              width: ~~(this.width / this.params.pixelRatio) + \"px\"\n            }), this.updateSize(), !0);\n          }\n        }, {\n          key: \"setHeight\",\n          value: function (e) {\n            return e != this.height && (this.height = e, this.style(this.wrapper, {\n              height: ~~(this.height / this.params.pixelRatio) + \"px\"\n            }), this.updateSize(), !0);\n          }\n        }, {\n          key: \"progress\",\n          value: function (e) {\n            var t = 1 / this.params.pixelRatio,\n                r = Math.round(e * this.width) * t;\n\n            if (r < this.lastPos || r - this.lastPos >= t) {\n              if (this.lastPos = r, this.params.scrollParent && this.params.autoCenter) {\n                var n = ~~(this.wrapper.scrollWidth * e);\n                this.recenterOnPosition(n);\n              }\n\n              this.updateProgress(r);\n            }\n          }\n        }, {\n          key: \"destroy\",\n          value: function () {\n            this.unAll(), this.wrapper && (this.wrapper.parentNode == this.container && this.container.removeChild(this.wrapper), this.wrapper = null);\n          }\n        }, {\n          key: \"updateCursor\",\n          value: function () {}\n        }, {\n          key: \"updateSize\",\n          value: function () {}\n        }, {\n          key: \"drawBars\",\n          value: function (e, t, r, n) {}\n        }, {\n          key: \"drawWave\",\n          value: function (e, t, r, n) {}\n        }, {\n          key: \"clearWave\",\n          value: function () {}\n        }, {\n          key: \"updateProgress\",\n          value: function (e) {}\n        }]) && a(r.prototype, i), t;\n      }();\n\n      t.default = l, e.exports = t.default;\n    }, function (e, t, r) {\n      Object.defineProperty(t, \"__esModule\", {\n        value: !0\n      }), t.default = void 0;\n      var n,\n          i = (n = r(3)) && n.__esModule ? n : {\n        default: n\n      };\n      !function (e) {\n        if (e && e.__esModule) return e;\n        var t = {};\n        if (null != e) for (var r in e) if (Object.prototype.hasOwnProperty.call(e, r)) {\n          var n = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(e, r) : {};\n          n.get || n.set ? Object.defineProperty(t, r, n) : t[r] = e[r];\n        }\n        t.default = e;\n      }(r(0));\n\n      function a(e) {\n        return (a = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (e) {\n          return typeof e;\n        } : function (e) {\n          return e && \"function\" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? \"symbol\" : typeof e;\n        })(e);\n      }\n\n      function s(e, t) {\n        for (var r = 0; r < t.length; r++) {\n          var n = t[r];\n          n.enumerable = n.enumerable || !1, n.configurable = !0, \"value\" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);\n        }\n      }\n\n      function o(e, t) {\n        return !t || \"object\" !== a(t) && \"function\" != typeof t ? function (e) {\n          if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n          return e;\n        }(e) : t;\n      }\n\n      function u(e, t, r) {\n        return (u = \"undefined\" != typeof Reflect && Reflect.get ? Reflect.get : function (e, t, r) {\n          var n = function (e, t) {\n            for (; !Object.prototype.hasOwnProperty.call(e, t) && null !== (e = l(e)););\n\n            return e;\n          }(e, t);\n\n          if (n) {\n            var i = Object.getOwnPropertyDescriptor(n, t);\n            return i.get ? i.get.call(r) : i.value;\n          }\n        })(e, t, r || e);\n      }\n\n      function l(e) {\n        return (l = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) {\n          return e.__proto__ || Object.getPrototypeOf(e);\n        })(e);\n      }\n\n      function c(e, t) {\n        return (c = Object.setPrototypeOf || function (e, t) {\n          return e.__proto__ = t, e;\n        })(e, t);\n      }\n\n      var h = function (e) {\n        function t(e) {\n          var r;\n          return function (e, t) {\n            if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n          }(this, t), (r = o(this, l(t).call(this, e))).params = e, r.media = {\n            currentTime: 0,\n            duration: 0,\n            paused: !0,\n            playbackRate: 1,\n            play: function () {},\n            pause: function () {},\n            volume: 0\n          }, r.mediaType = e.mediaType.toLowerCase(), r.elementPosition = e.elementPosition, r.peaks = null, r.playbackRate = 1, r.volume = 1, r.buffer = null, r.onPlayEnd = null, r;\n        }\n\n        var r, n;\n        return function (e, t) {\n          if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function\");\n          e.prototype = Object.create(t && t.prototype, {\n            constructor: {\n              value: e,\n              writable: !0,\n              configurable: !0\n            }\n          }), t && c(e, t);\n        }(t, i.default), r = t, (n = [{\n          key: \"init\",\n          value: function () {\n            this.setPlaybackRate(this.params.audioRate), this.createTimer();\n          }\n        }, {\n          key: \"createTimer\",\n          value: function () {\n            var e = this;\n            this.on(\"play\", function t() {\n              e.isPaused() || (e.fireEvent(\"audioprocess\", e.getCurrentTime()), (window.requestAnimationFrame || window.webkitRequestAnimationFrame)(t));\n            }), this.on(\"pause\", function () {\n              e.fireEvent(\"audioprocess\", e.getCurrentTime());\n            });\n          }\n        }, {\n          key: \"load\",\n          value: function (e, t, r, n) {\n            var i = document.createElement(this.mediaType);\n            i.controls = this.params.mediaControls, i.autoplay = this.params.autoplay || !1, i.preload = null == n ? \"auto\" : n, i.src = e, i.style.width = \"100%\";\n            var a = t.querySelector(this.mediaType);\n            a && t.removeChild(a), t.appendChild(i), this._load(i, r);\n          }\n        }, {\n          key: \"loadElt\",\n          value: function (e, t) {\n            e.controls = this.params.mediaControls, e.autoplay = this.params.autoplay || !1, this._load(e, t);\n          }\n        }, {\n          key: \"_load\",\n          value: function (e, t) {\n            var r = this;\n            \"function\" == typeof e.load && e.load(), e.addEventListener(\"error\", function () {\n              r.fireEvent(\"error\", \"Error loading media element\");\n            }), e.addEventListener(\"canplay\", function () {\n              r.fireEvent(\"canplay\");\n            }), e.addEventListener(\"ended\", function () {\n              r.fireEvent(\"finish\");\n            }), e.addEventListener(\"play\", function () {\n              r.fireEvent(\"play\");\n            }), e.addEventListener(\"pause\", function () {\n              r.fireEvent(\"pause\");\n            }), this.media = e, this.peaks = t, this.onPlayEnd = null, this.buffer = null, this.setPlaybackRate(this.playbackRate), this.setVolume(this.volume);\n          }\n        }, {\n          key: \"isPaused\",\n          value: function () {\n            return !this.media || this.media.paused;\n          }\n        }, {\n          key: \"getDuration\",\n          value: function () {\n            if (this.explicitDuration) return this.explicitDuration;\n            var e = (this.buffer || this.media).duration;\n            return e >= 1 / 0 && (e = this.media.seekable.end(0)), e;\n          }\n        }, {\n          key: \"getCurrentTime\",\n          value: function () {\n            return this.media && this.media.currentTime;\n          }\n        }, {\n          key: \"getPlayedPercents\",\n          value: function () {\n            return this.getCurrentTime() / this.getDuration() || 0;\n          }\n        }, {\n          key: \"getPlaybackRate\",\n          value: function () {\n            return this.playbackRate || this.media.playbackRate;\n          }\n        }, {\n          key: \"setPlaybackRate\",\n          value: function (e) {\n            this.playbackRate = e || 1, this.media.playbackRate = this.playbackRate;\n          }\n        }, {\n          key: \"seekTo\",\n          value: function (e) {\n            null != e && (this.media.currentTime = e), this.clearPlayEnd();\n          }\n        }, {\n          key: \"play\",\n          value: function (e, t) {\n            this.seekTo(e);\n            var r = this.media.play();\n            return t && this.setPlayEnd(t), r;\n          }\n        }, {\n          key: \"pause\",\n          value: function () {\n            var e;\n            return this.media && (e = this.media.pause()), this.clearPlayEnd(), e;\n          }\n        }, {\n          key: \"setPlayEnd\",\n          value: function (e) {\n            var t = this;\n            this._onPlayEnd = function (r) {\n              r >= e && (t.pause(), t.seekTo(e));\n            }, this.on(\"audioprocess\", this._onPlayEnd);\n          }\n        }, {\n          key: \"clearPlayEnd\",\n          value: function () {\n            this._onPlayEnd && (this.un(\"audioprocess\", this._onPlayEnd), this._onPlayEnd = null);\n          }\n        }, {\n          key: \"getPeaks\",\n          value: function (e, r, n) {\n            return this.buffer ? u(l(t.prototype), \"getPeaks\", this).call(this, e, r, n) : this.peaks || [];\n          }\n        }, {\n          key: \"setSinkId\",\n          value: function (e) {\n            return e ? this.media.setSinkId ? this.media.setSinkId(e) : Promise.reject(new Error(\"setSinkId is not supported in your browser\")) : Promise.reject(new Error(\"Invalid deviceId: \" + e));\n          }\n        }, {\n          key: \"getVolume\",\n          value: function () {\n            return this.volume || this.media.volume;\n          }\n        }, {\n          key: \"setVolume\",\n          value: function (e) {\n            this.volume = e, this.media.volume = this.volume;\n          }\n        }, {\n          key: \"destroy\",\n          value: function () {\n            this.pause(), this.unAll(), this.params.removeMediaElementOnDestroy && this.media && this.media.parentNode && this.media.parentNode.removeChild(this.media), this.media = null;\n          }\n        }]) && s(r.prototype, n), t;\n      }();\n\n      t.default = h, e.exports = t.default;\n    }, function (e, t, r) {\n      function n(e, t) {\n        for (var r = 0; r < t.length; r++) {\n          var n = t[r];\n          n.enumerable = n.enumerable || !1, n.configurable = !0, \"value\" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);\n        }\n      }\n\n      Object.defineProperty(t, \"__esModule\", {\n        value: !0\n      }), t.default = void 0;\n\n      var i = function () {\n        function e() {\n          !function (e, t) {\n            if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n          }(this, e), this.clearPeakCache();\n        }\n\n        var t, r;\n        return t = e, (r = [{\n          key: \"clearPeakCache\",\n          value: function () {\n            this.peakCacheRanges = [], this.peakCacheLength = -1;\n          }\n        }, {\n          key: \"addRangeToPeakCache\",\n          value: function (e, t, r) {\n            e != this.peakCacheLength && (this.clearPeakCache(), this.peakCacheLength = e);\n\n            for (var n = [], i = 0; i < this.peakCacheRanges.length && this.peakCacheRanges[i] < t;) i++;\n\n            for (i % 2 == 0 && n.push(t); i < this.peakCacheRanges.length && this.peakCacheRanges[i] <= r;) n.push(this.peakCacheRanges[i]), i++;\n\n            i % 2 == 0 && n.push(r), n = n.filter(function (e, t, r) {\n              return 0 == t ? e != r[t + 1] : t == r.length - 1 ? e != r[t - 1] : e != r[t - 1] && e != r[t + 1];\n            }), this.peakCacheRanges = this.peakCacheRanges.concat(n), this.peakCacheRanges = this.peakCacheRanges.sort(function (e, t) {\n              return e - t;\n            }).filter(function (e, t, r) {\n              return 0 == t ? e != r[t + 1] : t == r.length - 1 ? e != r[t - 1] : e != r[t - 1] && e != r[t + 1];\n            });\n            var a = [];\n\n            for (i = 0; i < n.length; i += 2) a.push([n[i], n[i + 1]]);\n\n            return a;\n          }\n        }, {\n          key: \"getCacheRanges\",\n          value: function () {\n            var e,\n                t = [];\n\n            for (e = 0; e < this.peakCacheRanges.length; e += 2) t.push([this.peakCacheRanges[e], this.peakCacheRanges[e + 1]]);\n\n            return t;\n          }\n        }]) && n(t.prototype, r), e;\n      }();\n\n      t.default = i, e.exports = t.default;\n    }]);\n  });\n});\nvar WaveSurfer = unwrapExports(wavesurfer_min);\nvar wavesurfer_min_1 = wavesurfer_min.WaveSurfer;\n/**\n * @typedef {Object} MicrophonePluginParams\n * @property {MediaStreamConstraints} constraints The constraints parameter is a\n * MediaStreamConstaints object with two members: video and audio, describing\n * the media types requested. Either or both must be specified.\n * @property {number} bufferSize=4096 The buffer size in units of sample-frames.\n * If specified, the bufferSize must be one of the following values: `256`,\n * `512`, `1024`, `2048`, `4096`, `8192`, `16384`\n * @property {number} numberOfInputChannels=1 Integer specifying the number of\n * channels for this node's input. Values of up to 32 are supported.\n * @property {?boolean} deferInit Set to true to manually call\n * `initPlugin('microphone')`\n */\n\n/**\n * Visualize microphone input in a wavesurfer instance.\n *\n * @implements {PluginClass}\n * @extends {Observer}\n * @example\n * // es6\n * import MicrophonePlugin from 'wavesurfer.microphone.js';\n *\n * // commonjs\n * var MicrophonePlugin = require('wavesurfer.microphone.js');\n *\n * // if you are using <script> tags\n * var MicrophonePlugin = window.WaveSurfer.microphone;\n *\n * // ... initialising wavesurfer with the plugin\n * var wavesurfer = WaveSurfer.create({\n *   // wavesurfer options ...\n *   plugins: [\n *     MicrophonePlugin.create({\n *       // plugin options ...\n *     })\n *   ]\n * });\n */\n\nclass MicrophonePlugin {\n  /**\n   * Microphone plugin definition factory\n   *\n   * This function must be used to create a plugin definition which can be\n   * used by wavesurfer to correctly instantiate the plugin.\n   *\n   * @param  {MicrophonePluginParams} params parameters use to initialise the plugin\n   * @return {PluginDefinition} an object representing the plugin\n   */\n  static create(params) {\n    return {\n      name: 'microphone',\n      deferInit: params && params.deferInit ? params.deferInit : false,\n      params: params,\n      instance: MicrophonePlugin\n    };\n  }\n\n  constructor(params, ws) {\n    this.params = params;\n    this.wavesurfer = ws;\n    this.active = false;\n    this.paused = false;\n    this.browser = this.detectBrowser();\n\n    this.reloadBufferFunction = e => this.reloadBuffer(e); // cross-browser getUserMedia\n\n\n    const promisifiedOldGUM = (constraints, successCallback, errorCallback) => {\n      // get a hold of getUserMedia, if present\n      const getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia; // Some browsers just don't implement it - return a rejected\n      // promise with an error to keep a consistent interface\n\n      if (!getUserMedia) {\n        return Promise.reject(new Error('getUserMedia is not implemented in this browser'));\n      } // otherwise, wrap the call to the old navigator.getUserMedia with\n      // a Promise\n\n\n      return new Promise((successCallback, errorCallback) => {\n        getUserMedia.call(navigator, constraints, successCallback, errorCallback);\n      });\n    }; // Older browsers might not implement mediaDevices at all, so we set an\n    // empty object first\n\n\n    if (navigator.mediaDevices === undefined) {\n      navigator.mediaDevices = {};\n    } // Some browsers partially implement mediaDevices. We can't just assign\n    // an object with getUserMedia as it would overwrite existing\n    // properties. Here, we will just add the getUserMedia property if it's\n    // missing.\n\n\n    if (navigator.mediaDevices.getUserMedia === undefined) {\n      navigator.mediaDevices.getUserMedia = promisifiedOldGUM;\n    }\n\n    this.constraints = this.params.constraints || {\n      video: false,\n      audio: true\n    };\n    this.bufferSize = this.params.bufferSize || 4096;\n    this.numberOfInputChannels = this.params.numberOfInputChannels || 1;\n    this.numberOfOutputChannels = this.params.numberOfOutputChannels || 1;\n\n    this._onBackendCreated = () => {\n      // wavesurfer's AudioContext where we'll route the mic signal to\n      this.micContext = this.wavesurfer.backend.getAudioContext();\n    };\n  }\n\n  init() {\n    this.wavesurfer.on('backend-created', this._onBackendCreated);\n\n    if (this.wavesurfer.backend) {\n      this._onBackendCreated();\n    }\n  }\n  /**\n   * Destroy the microphone plugin.\n   */\n\n\n  destroy() {\n    // make sure the buffer is not redrawn during\n    // cleanup and demolition of this plugin.\n    this.paused = true;\n    this.wavesurfer.un('backend-created', this._onBackendCreated);\n    this.stop();\n  }\n  /**\n   * Allow user to select audio input device, e.g. microphone, and\n   * start the visualization.\n   */\n\n\n  start() {\n    navigator.mediaDevices.getUserMedia(this.constraints).then(data => this.gotStream(data)).catch(data => this.deviceError(data));\n  }\n  /**\n   * Pause/resume visualization.\n   */\n\n\n  togglePlay() {\n    if (!this.active) {\n      // start it first\n      this.start();\n    } else {\n      // toggle paused\n      this.paused = !this.paused;\n\n      if (this.paused) {\n        this.pause();\n      } else {\n        this.play();\n      }\n    }\n  }\n  /**\n   * Play visualization.\n   */\n\n\n  play() {\n    this.paused = false;\n    this.connect();\n  }\n  /**\n   * Pause visualization.\n   */\n\n\n  pause() {\n    this.paused = true; // disconnect sources so they can be used elsewhere\n    // (eg. during audio playback)\n\n    this.disconnect();\n  }\n  /**\n   * Stop the device stream and remove any remaining waveform drawing from\n   * the wavesurfer canvas.\n   */\n\n\n  stop() {\n    if (this.active) {\n      // stop visualization and device\n      this.stopDevice(); // empty last frame\n\n      this.wavesurfer.empty();\n    }\n  }\n  /**\n   * Stop the device and the visualization.\n   */\n\n\n  stopDevice() {\n    this.active = false; // stop visualization\n\n    this.disconnect(); // stop stream from device\n\n    if (this.stream) {\n      // MediaStream.stop is deprecated since:\n      // - Firefox 44 (https://www.fxsitecompat.com/en-US/docs/2015/mediastream-stop-has-been-deprecated/)\n      // - Chrome 45 (https://developers.google.com/web/updates/2015/07/mediastream-deprecations)\n      if (this.browser.browser === 'chrome' && this.browser.version >= 45 || this.browser.browser === 'firefox' && this.browser.version >= 44 || this.browser.browser === 'edge' || this.browser.browser === 'safari') {\n        if (this.stream.getTracks) {\n          // note that this should not be a call\n          this.stream.getTracks().forEach(stream => stream.stop());\n          return;\n        }\n      }\n\n      this.stream.stop();\n    }\n  }\n  /**\n   * Connect the media sources that feed the visualization.\n   */\n\n\n  connect() {\n    if (this.stream !== undefined) {\n      // Create a local buffer for data to be copied to the Wavesurfer buffer for Edge\n      if (this.browser.browser === 'edge') {\n        this.localAudioBuffer = this.micContext.createBuffer(this.numberOfInputChannels, this.bufferSize, this.micContext.sampleRate);\n      } // Create an AudioNode from the stream.\n\n\n      this.mediaStreamSource = this.micContext.createMediaStreamSource(this.stream);\n      this.levelChecker = this.micContext.createScriptProcessor(this.bufferSize, this.numberOfInputChannels, this.numberOfOutputChannels);\n      this.mediaStreamSource.connect(this.levelChecker);\n      this.levelChecker.connect(this.micContext.destination);\n      this.levelChecker.onaudioprocess = this.reloadBufferFunction;\n    }\n  }\n  /**\n   * Disconnect the media sources that feed the visualization.\n   */\n\n\n  disconnect() {\n    if (this.mediaStreamSource !== undefined) {\n      this.mediaStreamSource.disconnect();\n    }\n\n    if (this.levelChecker !== undefined) {\n      this.levelChecker.disconnect();\n      this.levelChecker.onaudioprocess = undefined;\n    }\n\n    if (this.localAudioBuffer !== undefined) {\n      this.localAudioBuffer = undefined;\n    }\n  }\n  /**\n   * Redraw the waveform.\n   */\n\n\n  reloadBuffer(event) {\n    if (!this.paused) {\n      this.wavesurfer.empty();\n\n      if (this.browser.browser === 'edge') {\n        // copy audio data to a local audio buffer,\n        // from https://github.com/audiojs/audio-buffer-utils\n        let channel, l;\n\n        for (channel = 0, l = Math.min(this.localAudioBuffer.numberOfChannels, event.inputBuffer.numberOfChannels); channel < l; channel++) {\n          this.localAudioBuffer.getChannelData(channel).set(event.inputBuffer.getChannelData(channel));\n        }\n\n        this.wavesurfer.loadDecodedBuffer(this.localAudioBuffer);\n      } else {\n        this.wavesurfer.loadDecodedBuffer(event.inputBuffer);\n      }\n    }\n  }\n  /**\n   * Audio input device is ready.\n   *\n   * @param {LocalMediaStream} stream The microphone's media stream.\n   */\n\n\n  gotStream(stream) {\n    this.stream = stream;\n    this.active = true; // start visualization\n\n    this.play(); // notify listeners\n\n    this.fireEvent('deviceReady', stream);\n  }\n  /**\n   * Device error callback.\n   */\n\n\n  deviceError(code) {\n    // notify listeners\n    this.fireEvent('deviceError', code);\n  }\n  /**\n   * Extract browser version out of the provided user agent string.\n   * @param {!string} uastring userAgent string.\n   * @param {!string} expr Regular expression used as match criteria.\n   * @param {!number} pos position in the version string to be returned.\n   * @return {!number} browser version.\n   */\n\n\n  extractVersion(uastring, expr, pos) {\n    const match = uastring.match(expr);\n    return match && match.length >= pos && parseInt(match[pos], 10);\n  }\n  /**\n   * Browser detector.\n   * @return {object} result containing browser, version and minVersion\n   *     properties.\n   */\n\n\n  detectBrowser() {\n    // Returned result object.\n    const result = {};\n    result.browser = null;\n    result.version = null;\n    result.minVersion = null; // Non supported browser.\n\n    if (typeof window === 'undefined' || !window.navigator) {\n      result.browser = 'Not a supported browser.';\n      return result;\n    }\n\n    if (navigator.mozGetUserMedia) {\n      // Firefox\n      result.browser = 'firefox';\n      result.version = this.extractVersion(navigator.userAgent, /Firefox\\/(\\d+)\\./, 1);\n      result.minVersion = 31;\n      return result;\n    } else if (navigator.webkitGetUserMedia) {\n      // Chrome/Chromium/Webview/Opera\n      result.browser = 'chrome';\n      result.version = this.extractVersion(navigator.userAgent, /Chrom(e|ium)\\/(\\d+)\\./, 2);\n      result.minVersion = 38;\n      return result;\n    } else if (navigator.mediaDevices && navigator.userAgent.match(/Edge\\/(\\d+).(\\d+)$/)) {\n      // Edge\n      result.browser = 'edge';\n      result.version = this.extractVersion(navigator.userAgent, /Edge\\/(\\d+).(\\d+)$/, 2);\n      result.minVersion = 10547;\n      return result;\n    } else if (window.RTCPeerConnection && navigator.userAgent.match(/AppleWebKit\\/(\\d+)\\./)) {\n      // Safari\n      result.browser = 'safari';\n      result.minVersion = 11;\n      result.version = this.extractVersion(navigator.userAgent, /AppleWebKit\\/(\\d+)\\./, 1);\n      return result;\n    } // Non supported browser default.\n\n\n    result.browser = 'Not a supported browser.';\n    return result;\n  }\n\n}\n/**\n * (Single) Region plugin class\n *\n * Must be turned into an observer before instantiating. This is done in\n * RegionsPlugin (main plugin class)\n *\n * @extends {Observer}\n */\n\n\nclass Region {\n  constructor(params, ws) {\n    this.wavesurfer = ws;\n    this.wrapper = ws.drawer.wrapper;\n    this.util = ws.util;\n    this.style = this.util.style;\n    this.id = params.id == null ? ws.util.getId() : params.id;\n    this.start = Number(params.start) || 0;\n    this.end = params.end == null ? // small marker-like region\n    this.start + 4 / this.wrapper.scrollWidth * this.wavesurfer.getDuration() : Number(params.end);\n    this.resize = params.resize === undefined ? true : Boolean(params.resize);\n    this.drag = params.drag === undefined ? true : Boolean(params.drag);\n    this.loop = Boolean(params.loop);\n    this.color = params.color || 'rgba(0, 0, 0, 0.1)';\n    this.data = params.data || {};\n    this.attributes = params.attributes || {};\n    this.maxLength = params.maxLength;\n    this.minLength = params.minLength;\n\n    this._onRedraw = () => this.updateRender();\n\n    this.scroll = params.scroll !== false && ws.params.scrollParent;\n    this.scrollSpeed = params.scrollSpeed || 1;\n    this.scrollThreshold = params.scrollThreshold || 10;\n    this.bindInOut();\n    this.render();\n    this.wavesurfer.on('zoom', this._onRedraw);\n    this.wavesurfer.on('redraw', this._onRedraw);\n    this.wavesurfer.fireEvent('region-created', this);\n  }\n  /* Update region params. */\n\n\n  update(params) {\n    if (null != params.start) {\n      this.start = Number(params.start);\n    }\n\n    if (null != params.end) {\n      this.end = Number(params.end);\n    }\n\n    if (null != params.loop) {\n      this.loop = Boolean(params.loop);\n    }\n\n    if (null != params.color) {\n      this.color = params.color;\n    }\n\n    if (null != params.data) {\n      this.data = params.data;\n    }\n\n    if (null != params.resize) {\n      this.resize = Boolean(params.resize);\n    }\n\n    if (null != params.drag) {\n      this.drag = Boolean(params.drag);\n    }\n\n    if (null != params.maxLength) {\n      this.maxLength = Number(params.maxLength);\n    }\n\n    if (null != params.minLength) {\n      this.minLength = Number(params.minLength);\n    }\n\n    if (null != params.attributes) {\n      this.attributes = params.attributes;\n    }\n\n    this.updateRender();\n    this.fireEvent('update');\n    this.wavesurfer.fireEvent('region-updated', this);\n  }\n  /* Remove a single region. */\n\n\n  remove() {\n    if (this.element) {\n      this.wrapper.removeChild(this.element);\n      this.element = null;\n      this.fireEvent('remove');\n      this.wavesurfer.un('zoom', this._onRedraw);\n      this.wavesurfer.un('redraw', this._onRedraw);\n      this.wavesurfer.fireEvent('region-removed', this);\n    }\n  }\n  /* Play the audio region. */\n\n\n  play() {\n    this.wavesurfer.play(this.start, this.end);\n    this.fireEvent('play');\n    this.wavesurfer.fireEvent('region-play', this);\n  }\n  /* Play the region in loop. */\n\n\n  playLoop() {\n    this.play();\n    this.once('out', () => this.playLoop());\n  }\n  /* Render a region as a DOM element. */\n\n\n  render() {\n    const regionEl = document.createElement('region');\n    regionEl.className = 'wavesurfer-region';\n    regionEl.title = this.formatTime(this.start, this.end);\n    regionEl.setAttribute('data-id', this.id);\n\n    for (const attrname in this.attributes) {\n      regionEl.setAttribute('data-region-' + attrname, this.attributes[attrname]);\n    }\n\n    const width = this.wrapper.scrollWidth;\n    this.style(regionEl, {\n      position: 'absolute',\n      zIndex: 2,\n      height: '100%',\n      top: '0px'\n    });\n    /* Resize handles */\n\n    if (this.resize) {\n      const handleLeft = regionEl.appendChild(document.createElement('handle'));\n      const handleRight = regionEl.appendChild(document.createElement('handle'));\n      handleLeft.className = 'wavesurfer-handle wavesurfer-handle-start';\n      handleRight.className = 'wavesurfer-handle wavesurfer-handle-end';\n      const css = {\n        cursor: 'col-resize',\n        position: 'absolute',\n        left: '0px',\n        top: '0px',\n        width: '1%',\n        maxWidth: '4px',\n        height: '100%'\n      };\n      this.style(handleLeft, css);\n      this.style(handleRight, css);\n      this.style(handleRight, {\n        left: '100%'\n      });\n    }\n\n    this.element = this.wrapper.appendChild(regionEl);\n    this.updateRender();\n    this.bindEvents(regionEl);\n  }\n\n  formatTime(start, end) {\n    return (start == end ? [start] : [start, end]).map(time => [Math.floor(time % 3600 / 60), // minutes\n    ('00' + Math.floor(time % 60)).slice(-2) // seconds\n    ].join(':')).join('-');\n  }\n\n  getWidth() {\n    return this.wavesurfer.drawer.width / this.wavesurfer.params.pixelRatio;\n  }\n  /* Update element's position, width, color. */\n\n\n  updateRender() {\n    // duration varies during loading process, so don't overwrite important data\n    const dur = this.wavesurfer.getDuration();\n    const width = this.getWidth();\n    var startLimited = this.start;\n    var endLimited = this.end;\n\n    if (startLimited < 0) {\n      startLimited = 0;\n      endLimited = endLimited - startLimited;\n    }\n\n    if (endLimited > dur) {\n      endLimited = dur;\n      startLimited = dur - (endLimited - startLimited);\n    }\n\n    if (this.minLength != null) {\n      endLimited = Math.max(startLimited + this.minLength, endLimited);\n    }\n\n    if (this.maxLength != null) {\n      endLimited = Math.min(startLimited + this.maxLength, endLimited);\n    }\n\n    if (this.element != null) {\n      // Calculate the left and width values of the region such that\n      // no gaps appear between regions.\n      const left = Math.round(startLimited / dur * width);\n      const regionWidth = Math.round(endLimited / dur * width) - left;\n      this.style(this.element, {\n        left: left + 'px',\n        width: regionWidth + 'px',\n        backgroundColor: this.color,\n        cursor: this.drag ? 'move' : 'default'\n      });\n\n      for (const attrname in this.attributes) {\n        this.element.setAttribute('data-region-' + attrname, this.attributes[attrname]);\n      }\n\n      this.element.title = this.formatTime(this.start, this.end);\n    }\n  }\n  /* Bind audio events. */\n\n\n  bindInOut() {\n    this.firedIn = false;\n    this.firedOut = false;\n\n    const onProcess = time => {\n      if (!this.firedOut && this.firedIn && (this.start >= Math.round(time * 100) / 100 || this.end <= Math.round(time * 100) / 100)) {\n        this.firedOut = true;\n        this.firedIn = false;\n        this.fireEvent('out');\n        this.wavesurfer.fireEvent('region-out', this);\n      }\n\n      if (!this.firedIn && this.start <= time && this.end > time) {\n        this.firedIn = true;\n        this.firedOut = false;\n        this.fireEvent('in');\n        this.wavesurfer.fireEvent('region-in', this);\n      }\n    };\n\n    this.wavesurfer.backend.on('audioprocess', onProcess);\n    this.on('remove', () => {\n      this.wavesurfer.backend.un('audioprocess', onProcess);\n    });\n    /* Loop playback. */\n\n    this.on('out', () => {\n      if (this.loop) {\n        this.wavesurfer.play(this.start);\n      }\n    });\n  }\n  /* Bind DOM events. */\n\n\n  bindEvents() {\n    this.element.addEventListener('mouseenter', e => {\n      this.fireEvent('mouseenter', e);\n      this.wavesurfer.fireEvent('region-mouseenter', this, e);\n    });\n    this.element.addEventListener('mouseleave', e => {\n      this.fireEvent('mouseleave', e);\n      this.wavesurfer.fireEvent('region-mouseleave', this, e);\n    });\n    this.element.addEventListener('click', e => {\n      e.preventDefault();\n      this.fireEvent('click', e);\n      this.wavesurfer.fireEvent('region-click', this, e);\n    });\n    this.element.addEventListener('dblclick', e => {\n      e.stopPropagation();\n      e.preventDefault();\n      this.fireEvent('dblclick', e);\n      this.wavesurfer.fireEvent('region-dblclick', this, e);\n    });\n    /* Drag or resize on mousemove. */\n\n    (this.drag || this.resize) && (() => {\n      const container = this.wavesurfer.drawer.container;\n      const duration = this.wavesurfer.getDuration();\n      const scrollSpeed = this.scrollSpeed;\n      const scrollThreshold = this.scrollThreshold;\n      let startTime;\n      let touchId;\n      let drag;\n      let maxScroll;\n      let resize;\n      let updated = false;\n      let scrollDirection;\n      let wrapperRect; // Scroll when the user is dragging within the threshold\n\n      const edgeScroll = e => {\n        if (!scrollDirection || !drag && !resize) {\n          return;\n        } // Update scroll position\n\n\n        let scrollLeft = this.wrapper.scrollLeft + scrollSpeed * scrollDirection;\n        this.wrapper.scrollLeft = scrollLeft = Math.min(maxScroll, Math.max(0, scrollLeft)); // Update time\n\n        const time = this.wavesurfer.drawer.handleEvent(e) * duration;\n        const delta = time - startTime;\n        startTime = time; // Continue dragging or resizing\n\n        drag ? this.onDrag(delta) : this.onResize(delta, resize); // Repeat\n\n        window.requestAnimationFrame(() => {\n          edgeScroll(e);\n        });\n      };\n\n      const onDown = e => {\n        if (e.touches && e.touches.length > 1) {\n          return;\n        }\n\n        touchId = e.targetTouches ? e.targetTouches[0].identifier : null;\n        e.stopPropagation();\n        startTime = this.wavesurfer.drawer.handleEvent(e, true) * duration; // Store for scroll calculations\n\n        maxScroll = this.wrapper.scrollWidth - this.wrapper.clientWidth;\n        wrapperRect = this.wrapper.getBoundingClientRect();\n\n        if (e.target.tagName.toLowerCase() == 'handle') {\n          if (e.target.classList.contains('wavesurfer-handle-start')) {\n            resize = 'start';\n          } else {\n            resize = 'end';\n          }\n        } else {\n          drag = true;\n          resize = false;\n        }\n      };\n\n      const onUp = e => {\n        if (e.touches && e.touches.length > 1) {\n          return;\n        }\n\n        if (drag || resize) {\n          drag = false;\n          scrollDirection = null;\n          resize = false;\n        }\n\n        if (updated) {\n          updated = false;\n          this.util.preventClick();\n          this.fireEvent('update-end', e);\n          this.wavesurfer.fireEvent('region-update-end', this, e);\n        }\n      };\n\n      const onMove = e => {\n        if (e.touches && e.touches.length > 1) {\n          return;\n        }\n\n        if (e.targetTouches && e.targetTouches[0].identifier != touchId) {\n          return;\n        }\n\n        if (drag || resize) {\n          const oldTime = startTime;\n          const time = this.wavesurfer.drawer.handleEvent(e) * duration;\n          const delta = time - startTime;\n          startTime = time; // Drag\n\n          if (this.drag && drag) {\n            updated = updated || !!delta;\n            this.onDrag(delta);\n          } // Resize\n\n\n          if (this.resize && resize) {\n            updated = updated || !!delta;\n            this.onResize(delta, resize);\n          }\n\n          if (this.scroll && container.clientWidth < this.wrapper.scrollWidth) {\n            if (drag) {\n              // The threshold is not between the mouse and the container edge\n              // but is between the region and the container edge\n              const regionRect = this.element.getBoundingClientRect();\n              let x = regionRect.left - wrapperRect.left; // Check direction\n\n              if (time < oldTime && x >= 0) {\n                scrollDirection = -1;\n              } else if (time > oldTime && x + regionRect.width <= wrapperRect.right) {\n                scrollDirection = 1;\n              } // Check that we are still beyond the threshold\n\n\n              if (scrollDirection === -1 && x > scrollThreshold || scrollDirection === 1 && x + regionRect.width < wrapperRect.right - scrollThreshold) {\n                scrollDirection = null;\n              }\n            } else {\n              // Mouse based threshold\n              let x = e.clientX - wrapperRect.left; // Check direction\n\n              if (x <= scrollThreshold) {\n                scrollDirection = -1;\n              } else if (x >= wrapperRect.right - scrollThreshold) {\n                scrollDirection = 1;\n              } else {\n                scrollDirection = null;\n              }\n            }\n\n            scrollDirection && edgeScroll(e);\n          }\n        }\n      };\n\n      this.element.addEventListener('mousedown', onDown);\n      this.element.addEventListener('touchstart', onDown);\n      this.wrapper.addEventListener('mousemove', onMove);\n      this.wrapper.addEventListener('touchmove', onMove);\n      document.body.addEventListener('mouseup', onUp);\n      document.body.addEventListener('touchend', onUp);\n      this.on('remove', () => {\n        document.body.removeEventListener('mouseup', onUp);\n        document.body.removeEventListener('touchend', onUp);\n        this.wrapper.removeEventListener('mousemove', onMove);\n        this.wrapper.removeEventListener('touchmove', onMove);\n      });\n      this.wavesurfer.on('destroy', () => {\n        document.body.removeEventListener('mouseup', onUp);\n        document.body.removeEventListener('touchend', onUp);\n      });\n    })();\n  }\n\n  onDrag(delta) {\n    const maxEnd = this.wavesurfer.getDuration();\n\n    if (this.end + delta > maxEnd || this.start + delta < 0) {\n      return;\n    }\n\n    this.update({\n      start: this.start + delta,\n      end: this.end + delta\n    });\n  }\n\n  onResize(delta, direction) {\n    if (direction == 'start') {\n      this.update({\n        start: Math.min(this.start + delta, this.end),\n        end: Math.max(this.start + delta, this.end)\n      });\n    } else {\n      this.update({\n        start: Math.min(this.end + delta, this.start),\n        end: Math.max(this.end + delta, this.start)\n      });\n    }\n  }\n\n}\n/**\n * @typedef {Object} RegionsPluginParams\n * @property {?boolean} dragSelection Enable creating regions by dragging with\n * the mouse\n * @property {?RegionParams[]} regions Regions that should be added upon\n * initialisation\n * @property {number} slop=2 The sensitivity of the mouse dragging\n * @property {?boolean} deferInit Set to true to manually call\n * `initPlugin('regions')`\n */\n\n/**\n * @typedef {Object} RegionParams\n * @desc The parameters used to describe a region.\n * @example wavesurfer.addRegion(regionParams);\n * @property {string} id=random The id of the region\n * @property {number} start=0 The start position of the region (in seconds).\n * @property {number} end=0 The end position of the region (in seconds).\n * @property {?boolean} loop Whether to loop the region when played back.\n * @property {boolean} drag=true Allow/disallow dragging the region.\n * @property {boolean} resize=true Allow/disallow resizing the region.\n * @property {string} [color='rgba(0, 0, 0, 0.1)'] HTML color code.\n */\n\n/**\n * Regions are visual overlays on waveform that can be used to play and loop\n * portions of audio. Regions can be dragged and resized.\n *\n * Visual customization is possible via CSS (using the selectors\n * `.wavesurfer-region` and `.wavesurfer-handle`).\n *\n * @implements {PluginClass}\n * @extends {Observer}\n *\n * @example\n * // es6\n * import RegionsPlugin from 'wavesurfer.regions.js';\n *\n * // commonjs\n * var RegionsPlugin = require('wavesurfer.regions.js');\n *\n * // if you are using <script> tags\n * var RegionsPlugin = window.WaveSurfer.regions;\n *\n * // ... initialising wavesurfer with the plugin\n * var wavesurfer = WaveSurfer.create({\n *   // wavesurfer options ...\n *   plugins: [\n *     RegionsPlugin.create({\n *       // plugin options ...\n *     })\n *   ]\n * });\n */\n\n\nclass RegionsPlugin {\n  /**\n   * Regions plugin definition factory\n   *\n   * This function must be used to create a plugin definition which can be\n   * used by wavesurfer to correctly instantiate the plugin.\n   *\n   * @param {RegionsPluginParams} params parameters use to initialise the plugin\n   * @return {PluginDefinition} an object representing the plugin\n   */\n  static create(params) {\n    return {\n      name: 'regions',\n      deferInit: params && params.deferInit ? params.deferInit : false,\n      params: params,\n      staticProps: {\n        initRegions() {\n          console.warn('Deprecated initRegions! Use wavesurfer.initPlugins(\"regions\") instead!');\n          this.initPlugin('regions');\n        },\n\n        addRegion(options) {\n          if (!this.initialisedPluginList.regions) {\n            this.initPlugin('regions');\n          }\n\n          return this.regions.add(options);\n        },\n\n        clearRegions() {\n          this.regions && this.regions.clear();\n        },\n\n        enableDragSelection(options) {\n          if (!this.initialisedPluginList.regions) {\n            this.initPlugin('regions');\n          }\n\n          this.regions.enableDragSelection(options);\n        },\n\n        disableDragSelection() {\n          this.regions.disableDragSelection();\n        }\n\n      },\n      instance: RegionsPlugin\n    };\n  }\n\n  constructor(params, ws) {\n    this.params = params;\n    this.wavesurfer = ws;\n    this.util = ws.util; // turn the plugin instance into an observer\n\n    const observerPrototypeKeys = Object.getOwnPropertyNames(this.util.Observer.prototype);\n    observerPrototypeKeys.forEach(key => {\n      Region.prototype[key] = this.util.Observer.prototype[key];\n    });\n    this.wavesurfer.Region = Region;\n\n    this._onBackendCreated = () => {\n      this.wrapper = this.wavesurfer.drawer.wrapper;\n\n      if (this.params.regions) {\n        this.params.regions.forEach(region => {\n          this.add(region);\n        });\n      }\n    }; // Id-based hash of regions.\n\n\n    this.list = {};\n\n    this._onReady = () => {\n      if (this.params.dragSelection) {\n        this.enableDragSelection(this.params);\n      }\n\n      Object.keys(this.list).forEach(id => {\n        this.list[id].updateRender();\n      });\n    };\n  }\n\n  init() {\n    // Check if ws is ready\n    if (this.wavesurfer.isReady) {\n      this._onBackendCreated();\n\n      this._onReady();\n    }\n\n    this.wavesurfer.on('ready', this._onReady);\n    this.wavesurfer.on('backend-created', this._onBackendCreated);\n  }\n\n  destroy() {\n    this.wavesurfer.un('ready', this._onReady);\n    this.wavesurfer.un('backend-created', this._onBackendCreated);\n    this.disableDragSelection();\n    this.clear();\n  }\n  /* Add a region. */\n\n\n  add(params) {\n    const region = new this.wavesurfer.Region(params, this.wavesurfer);\n    this.list[region.id] = region;\n    region.on('remove', () => {\n      delete this.list[region.id];\n    });\n    return region;\n  }\n  /* Remove all regions. */\n\n\n  clear() {\n    Object.keys(this.list).forEach(id => {\n      this.list[id].remove();\n    });\n  }\n\n  enableDragSelection(params) {\n    const slop = params.slop || 2;\n    const container = this.wavesurfer.drawer.container;\n    const scroll = params.scroll !== false && this.wavesurfer.params.scrollParent;\n    const scrollSpeed = params.scrollSpeed || 1;\n    const scrollThreshold = params.scrollThreshold || 10;\n    let drag;\n    let duration = this.wavesurfer.getDuration();\n    let maxScroll;\n    let start;\n    let region;\n    let touchId;\n    let pxMove = 0;\n    let scrollDirection;\n    let wrapperRect; // Scroll when the user is dragging within the threshold\n\n    const edgeScroll = e => {\n      if (!region || !scrollDirection) {\n        return;\n      } // Update scroll position\n\n\n      let scrollLeft = this.wrapper.scrollLeft + scrollSpeed * scrollDirection;\n      this.wrapper.scrollLeft = scrollLeft = Math.min(maxScroll, Math.max(0, scrollLeft)); // Update range\n\n      const end = this.wavesurfer.drawer.handleEvent(e);\n      region.update({\n        start: Math.min(end * duration, start * duration),\n        end: Math.max(end * duration, start * duration)\n      }); // Check that there is more to scroll and repeat\n\n      if (scrollLeft < maxScroll && scrollLeft > 0) {\n        window.requestAnimationFrame(() => {\n          edgeScroll(e);\n        });\n      }\n    };\n\n    const eventDown = e => {\n      if (e.touches && e.touches.length > 1) {\n        return;\n      }\n\n      duration = this.wavesurfer.getDuration();\n      touchId = e.targetTouches ? e.targetTouches[0].identifier : null; // Store for scroll calculations\n\n      maxScroll = this.wrapper.scrollWidth - this.wrapper.clientWidth;\n      wrapperRect = this.wrapper.getBoundingClientRect();\n      drag = true;\n      start = this.wavesurfer.drawer.handleEvent(e, true);\n      region = null;\n      scrollDirection = null;\n    };\n\n    this.wrapper.addEventListener('mousedown', eventDown);\n    this.wrapper.addEventListener('touchstart', eventDown);\n    this.on('disable-drag-selection', () => {\n      this.wrapper.removeEventListener('touchstart', eventDown);\n      this.wrapper.removeEventListener('mousedown', eventDown);\n    });\n\n    const eventUp = e => {\n      if (e.touches && e.touches.length > 1) {\n        return;\n      }\n\n      drag = false;\n      pxMove = 0;\n      scrollDirection = null;\n\n      if (region) {\n        this.util.preventClick();\n        region.fireEvent('update-end', e);\n        this.wavesurfer.fireEvent('region-update-end', region, e);\n      }\n\n      region = null;\n    };\n\n    this.wrapper.addEventListener('mouseup', eventUp);\n    this.wrapper.addEventListener('touchend', eventUp);\n    document.body.addEventListener('mouseup', eventUp);\n    document.body.addEventListener('touchend', eventUp);\n    this.on('disable-drag-selection', () => {\n      document.body.removeEventListener('mouseup', eventUp);\n      document.body.removeEventListener('touchend', eventUp);\n      this.wrapper.removeEventListener('touchend', eventUp);\n      this.wrapper.removeEventListener('mouseup', eventUp);\n    });\n\n    const eventMove = e => {\n      if (!drag) {\n        return;\n      }\n\n      if (++pxMove <= slop) {\n        return;\n      }\n\n      if (e.touches && e.touches.length > 1) {\n        return;\n      }\n\n      if (e.targetTouches && e.targetTouches[0].identifier != touchId) {\n        return;\n      }\n\n      if (!region) {\n        region = this.add(params || {});\n      }\n\n      const end = this.wavesurfer.drawer.handleEvent(e);\n      region.update({\n        start: Math.min(end * duration, start * duration),\n        end: Math.max(end * duration, start * duration)\n      }); // If scrolling is enabled\n\n      if (scroll && container.clientWidth < this.wrapper.scrollWidth) {\n        // Check threshold based on mouse\n        const x = e.clientX - wrapperRect.left;\n\n        if (x <= scrollThreshold) {\n          scrollDirection = -1;\n        } else if (x >= wrapperRect.right - scrollThreshold) {\n          scrollDirection = 1;\n        } else {\n          scrollDirection = null;\n        }\n\n        scrollDirection && edgeScroll(e);\n      }\n    };\n\n    this.wrapper.addEventListener('mousemove', eventMove);\n    this.wrapper.addEventListener('touchmove', eventMove);\n    this.on('disable-drag-selection', () => {\n      this.wrapper.removeEventListener('touchmove', eventMove);\n      this.wrapper.removeEventListener('mousemove', eventMove);\n    });\n  }\n\n  disableDragSelection() {\n    this.fireEvent('disable-drag-selection');\n  }\n  /* Get current region\n   *  The smallest region that contains the current time.\n   *  If several such regions exist, we take the first.\n   *  Return null if none exist. */\n\n\n  getCurrentRegion() {\n    const time = this.wavesurfer.getCurrentTime();\n    let min = null;\n    Object.keys(this.list).forEach(id => {\n      const cur = this.list[id];\n\n      if (cur.start <= time && cur.end >= time) {\n        if (!min || cur.end - cur.start < min.end - min.start) {\n          min = cur;\n        }\n      }\n    });\n    return min;\n  }\n\n}\n/**\n * @description Register event function\n */\n\n\nfunction registerEvent(wavesurfer, event, func) {\n  wavesurfer.on(event, func);\n}\n/**\n * @description Pass audio data to wavesurfer\n */\n\n\nfunction loadAudio(wavesurfer, audioFileOrElt, audioPeaks) {\n  if (audioFileOrElt instanceof window.HTMLElement) {\n    // media element\n    wavesurfer.loadMediaElement(audioFileOrElt, audioPeaks);\n  } else if (typeof audioFileOrElt === 'string') {\n    // bog-standard string is handled by load method and ajax call\n    wavesurfer.load(audioFileOrElt, audioPeaks);\n  } else if (audioFileOrElt instanceof window.Blob || audioFileOrElt instanceof window.File) {\n    // blob or file is loaded with loadBlob method\n    wavesurfer.loadBlob(audioFileOrElt, audioPeaks);\n  } else {\n    throw new Error('Wavesurfer._loadAudio expects prop audioFile\\n        to be either HTMLElement, string or file/blob');\n  }\n}\n/**\n * @description Capitalise the first letter of a string\n */\n\n\nfunction capitalizeFirstLetter(string) {\n  return string.split('-').map(function (part) {\n    return part.charAt(0).toUpperCase() + part.slice(1);\n  }).join('');\n}\n/**\n * @description Throws an error if the prop is defined and not an integer or not positive\n */\n\n\nfunction positiveIntegerProptype(props, propName, componentName) {\n  var n = props[propName];\n\n  if (n !== undefined && (typeof n !== 'number' || n !== parseInt(n, 10) || n < 0)) {\n    return new Error('Invalid ' + propName + ' supplied to ' + componentName + ',\\n      expected a positive integer');\n  }\n\n  return null;\n}\n/**\n * @description Receives seconds and transforms this to the position as a float 0-1\n */\n\n\nfunction _secToPos(duration, sec) {\n  return 1 / duration * sec;\n}\n/**\n * @description Seek to the position (in seconds)\n */\n\n\nfunction seekTo(wavesurfer, props) {\n  var duration = wavesurfer.getDuration() || props.duration;\n\n  var pos = _secToPos(duration, props.pos);\n\n  if (pos && !isNaN(pos)) {\n    if (props.autoCenter) {\n      wavesurfer.seekAndCenter(pos);\n    } else {\n      wavesurfer.seekTo(pos);\n    }\n  } else {\n    wavesurfer.seekTo(props.pos);\n  }\n}\n/**\n * @description load a media element selector or HTML element\n *              if selector, get the HTML element for it\n *              and pass to _loadAudio\n */\n\n\nfunction loadMediaElt(wavesurfer, selectorOrElt, audioPeaks) {\n  if (selectorOrElt instanceof window.HTMLElement) {\n    loadAudio(wavesurfer, selectorOrElt, audioPeaks);\n  } else {\n    if (!window.document.querySelector(selectorOrElt)) {\n      throw new Error('Media Element not found!');\n    }\n\n    loadAudio(wavesurfer, window.document.querySelector(selectorOrElt), audioPeaks);\n  }\n}\n\nvar EVENTS = ['audioprocess', 'destroy', 'error', 'finish', 'interaction', 'loading', 'mute', 'pause', 'play', 'ready', 'scroll', 'seek', 'volume', 'waveform-ready', 'zoom'];\nvar EVENT = {\n  // Fires continuously as the audio plays. Also fires on seeking.\n  AUDIO_PROCESS: EVENTS[0],\n  // When instance is destroyed.\n  DESTROY: EVENTS[1],\n  // Occurs on error. Callback will receive (string) error message.\n  ERROR: EVENTS[2],\n  // When it finishes playing.\n  FINISH: EVENTS[3],\n  // When there's interaction with the waveform.\n  INTERACTION: EVENTS[4],\n  // Fires continuously when loading via XHR or drag'n'drop. Callback will receive (integer) loading progress in percents [0..100] and (object) event target.\n  LOADING: EVENTS[5],\n  // On mute change. Callback will receive (boolean) new mute status.\n  MUTE: EVENTS[6],\n  // When audio is paused.\n  PAUSE: EVENTS[7],\n  // When playback starts.\n  PLAY: EVENTS[8],\n  // When audio is loaded, decoded and the waveform drawn. This fires before the waveform is drawn when using MediaElement, see waveform-ready.\n  READY: EVENTS[9],\n  // When the scrollbar is moved. Callback will receive a ScrollEvent object.\n  SCROLL: EVENTS[10],\n  // On seeking. Callback will receive (float) progress [0..1].\n  SEEK: EVENTS[11],\n  // On volume change. Callback will receive (integer) new volume.\n  VOLUME: EVENTS[12],\n  // Fires after the waveform is drawn when using the MediaElement backend. If you're using the WebAudio backend, you can use ready.\n  WAVEFORM_READY: EVENTS[13],\n  // On zooming. Callback will receive (integer) minPxPerSec.\n  ZOOM: EVENTS[14]\n};\nvar REGIONS_EVENTS = ['region-in', 'region-out', 'region-removed', 'region-updated', 'region-mouseenter', 'region-mouseleave', 'region-click', 'region-dblclick', 'region-update-end', 'region-play'];\nvar REGION_EVENTS = ['in', 'out', 'remove', 'update', 'click', 'dbclick', 'over', 'leave'];\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\nvar Waveform = function (_React$Component) {\n  inherits(Waveform, _React$Component);\n\n  function Waveform(props) {\n    classCallCheck(this, Waveform);\n\n    var _this = possibleConstructorReturn(this, (Waveform.__proto__ || Object.getPrototypeOf(Waveform)).call(this, props));\n\n    _this.state = {\n      isReady: false\n    };\n\n    if ((typeof WaveSurfer === 'undefined' ? 'undefined' : _typeof(WaveSurfer)) === undefined) {\n      throw new Error('WaveSurfer is undefined!');\n    }\n\n    return _this;\n  }\n\n  createClass(Waveform, [{\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      var _this2 = this;\n\n      var options = this.props.options;\n      options.plugins = [RegionsPlugin.create()];\n\n      if (this.props.micCallback) {\n        options.plugins.push(MicrophonePlugin.create());\n      }\n\n      this._wavesurfer = WaveSurfer.create(_extends({}, options, {\n        container: this.wavesurferEl\n      }));\n\n      if (this.props.micCallback) {\n        this._wavesurfer.microphone.on('deviceReady', function (stream) {\n          _this2.props.micCallback({\n            stream: stream\n          });\n        });\n\n        this._wavesurfer.microphone.on('deviceError', function (error) {\n          _this2.props.micCallback({\n            error: error\n          });\n        });\n\n        this.props.micCallback({\n          micInstance: this._wavesurfer.microphone\n        });\n      }\n\n      registerEvent(this._wavesurfer, EVENT.AUDIO_PROCESS, function (pos) {\n        var currentTime = Math.ceil(pos);\n\n        if (currentTime !== _this2.props.pos) {\n          _this2.props.onPosChange({\n            wavesurfer: _this2._wavesurfer,\n            originalArgs: [currentTime]\n          });\n        }\n      });\n      registerEvent(this._wavesurfer, EVENT.SEEK, function (pos) {\n        var duration = _this2._wavesurfer.getDuration();\n\n        var currentTime = Math.ceil(duration * pos);\n\n        if (currentTime !== _this2.props.pos) {\n          _this2.props.onPosChange({\n            wavesurfer: _this2._wavesurfer,\n            originalArgs: [currentTime]\n          });\n        }\n      }); // file was loaded, wave was drawn\n\n      registerEvent(this._wavesurfer, EVENT.READY, function () {\n        _this2.setState({\n          isReady: true\n        });\n\n        if (!_this2.props.micCallback) {\n          // set initial position\n          seekTo(_this2._wavesurfer, _this2.props, _this2.props.pos);\n        } // set initial volume\n\n\n        _this2._wavesurfer.setVolume(_this2.props.volume);\n\n        if (_this2.props.playing) {\n          // set initial playing state\n          _this2._wavesurfer.play();\n        } // set initial zoom\n\n\n        _this2._wavesurfer.zoom(_this2.props.zoom);\n      });\n      EVENTS.forEach(function (event) {\n        var capLetter = capitalizeFirstLetter(event);\n        var propCallback = _this2.props['on' + capLetter];\n\n        if (propCallback) {\n          registerEvent(_this2._wavesurfer, event, function () {\n            for (var _len = arguments.length, originalArgs = Array(_len), _key = 0; _key < _len; _key++) {\n              originalArgs[_key] = arguments[_key];\n            }\n\n            propCallback({\n              wavesurfer: _this2._wavesurfer,\n              originalArgs: originalArgs\n            });\n          });\n        }\n      }); // if audioFile prop, load file\n\n      if (this.props.audioFile) {\n        loadAudio(this._wavesurfer, this.props.audioFile, this.props.audioPeaks);\n      } // if mediaElt prop, load media Element\n\n\n      if (this.props.mediaElt) {\n        loadMediaElt(this._wavesurfer, this.props.mediaElt, this.props.audioPeaks);\n      }\n    }\n  }, {\n    key: 'componentWillReceiveProps',\n    value: function componentWillReceiveProps(nextProps) {\n      // update audioFile\n      if (this.props.audioFile !== nextProps.audioFile) {\n        this.setState({\n          isReady: false\n        });\n        loadAudio(this._wavesurfer, nextProps.audioFile, nextProps.audioPeaks);\n      } // update mediaElt\n\n\n      if (this.props.mediaElt !== nextProps.mediaElt) {\n        this.setState({\n          isReady: false\n        });\n        loadMediaElt(this._wavesurfer, nextProps.mediaElt, nextProps.audioPeaks);\n      } // update peaks\n\n\n      if (this.props.audioPeaks !== nextProps.audioPeaks) {\n        if (nextProps.mediaElt) {\n          loadMediaElt(this._wavesurfer, nextProps.mediaElt, nextProps.audioPeaks);\n        } else {\n          loadAudio(this._wavesurfer, nextProps.audioFile, nextProps.audioPeaks);\n        }\n      }\n\n      if (nextProps.playing) {\n        this._wavesurfer.play();\n      } else {\n        this._wavesurfer.pause();\n      } // update volume\n\n\n      if (this.props.volume !== nextProps.volume) {\n        this._wavesurfer.setVolume(nextProps.volume);\n      } // update zoom\n\n\n      if (this.props.zoom !== nextProps.zoom) {\n        this._wavesurfer.zoom(nextProps.zoom);\n      } // update audioRate\n\n\n      if (this.props.options.audioRate !== nextProps.options.audioRate) {\n        this._wavesurfer.setPlaybackRate(nextProps.options.audioRate);\n      }\n    }\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      // unsubscribe all listeners\n      this._wavesurfer.unAll(); // destroy wavesurfer instance\n\n\n      this._wavesurfer.destroy();\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _this3 = this;\n\n      var childrenWithProps = this.props.children ? React.Children.map(this.props.children, function (child) {\n        return React.cloneElement(child, {\n          wavesurfer: _this3._wavesurfer,\n          isReady: _this3.state.isReady\n        });\n      }) : false;\n      return React.createElement('div', {\n        className: 'waveform'\n      }, React.createElement('div', {\n        className: 'wave',\n        ref: function ref(c) {\n          _this3.wavesurferEl = c;\n        }\n      }), this._wavesurfer && this.state.isReady && childrenWithProps);\n    }\n  }]);\n  return Waveform;\n}(React.Component);\n\nfunction styleInject(css, ref) {\n  if (ref === void 0) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') {\n    return;\n  }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nvar css = \".styles_reactWaves__1M36F {\\n  width: 85%;\\n  display: inline-block;\\n  text-align: center;\\n  margin: 2em auto;\\n  padding: 4px 15px 0 40px;\\n  /* width */\\n  /* Track */\\n  /* Handle */\\n  /* Handle on hover */ }\\n  .styles_reactWaves__1M36F ::-webkit-scrollbar {\\n    margin-top: 20px;\\n    width: 8px;\\n    height: 8px; }\\n  .styles_reactWaves__1M36F ::-webkit-scrollbar-track {\\n    box-shadow: inset 0 0 1px grey;\\n    border-radius: 10px; }\\n  .styles_reactWaves__1M36F ::-webkit-scrollbar-thumb {\\n    background: #4F49E2;\\n    border-radius: 10px; }\\n  .styles_reactWaves__1M36F ::-webkit-scrollbar-thumb:hover {\\n    background: rgba(79, 73, 226, 0.85); }\\n\";\nvar styles = {\n  \"reactWaves\": \"styles_reactWaves__1M36F\"\n};\nstyleInject(css);\n\nvar Regions = function (_React$Component) {\n  inherits(Regions, _React$Component);\n\n  function Regions() {\n    classCallCheck(this, Regions);\n    return possibleConstructorReturn(this, (Regions.__proto__ || Object.getPrototypeOf(Regions)).apply(this, arguments));\n  }\n\n  createClass(Regions, [{\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      if (this.props.isReady) {\n        this._init.call(this);\n      }\n\n      this.props.wavesurfer.on('ready', this._init.bind(this));\n    }\n  }, {\n    key: 'componentWillReceiveProps',\n    value: function componentWillReceiveProps(nextProps) {\n      // only update if the wavesurfer instance has been ready\n      if (!this.props.isReady) {\n        return;\n      } // cache reference to old regions\n\n\n      var oldRegions = Object.create(this.props.wavesurfer.regions.list);\n      var newRegionId = void 0;\n      var oldRegionId = void 0;\n\n      for (newRegionId in nextProps.regions) {\n        if ({}.hasOwnProperty.call(nextProps.regions, newRegionId)) {\n          var newRegion = nextProps.regions[newRegionId]; // remove from oldRegions\n\n          delete oldRegions[newRegionId]; // new regions\n\n          if (!this.props.wavesurfer.regions.list[newRegionId] && nextProps.wavesurfer && nextProps.wavesurfer.addRegion) {\n            this._hookUpRegionEvents(nextProps.wavesurfer.addRegion(newRegion)); // update regions\n\n          } else if (oldRegions[newRegionId] && (oldRegions[newRegionId].start !== newRegion.start || oldRegions[newRegionId].end !== newRegion.end)) {\n            nextProps.wavesurfer.regions.list[newRegionId].update({\n              start: newRegion.start,\n              end: newRegion.end\n            });\n          }\n        }\n      } // remove any old regions\n\n\n      for (oldRegionId in oldRegions) {\n        if ({}.hasOwnProperty.call(oldRegions, oldRegionId)) {\n          nextProps.wavesurfer.regions.list[oldRegionId].remove();\n        }\n      }\n    }\n  }, {\n    key: 'shouldComponentUpdate',\n    value: function shouldComponentUpdate() {\n      return false;\n    }\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      var _this2 = this;\n\n      REGION_EVENTS.forEach(function (e) {\n        _this2.props.wavesurfer.un(e);\n      });\n    }\n  }, {\n    key: '_init',\n    value: function _init() {\n      var _this3 = this;\n\n      var _props = this.props,\n          wavesurfer = _props.wavesurfer,\n          regions = _props.regions;\n      var newRegionId = void 0;\n      REGIONS_EVENTS.forEach(function (e) {\n        var propCallback = _this3.props['on' + capitalizeFirstLetter(e)];\n\n        if (!propCallback) return;\n        wavesurfer.on(e, function () {\n          for (var _len = arguments.length, originalArgs = Array(_len), _key = 0; _key < _len; _key++) {\n            originalArgs[_key] = arguments[_key];\n          }\n\n          propCallback({\n            wavesurfer: wavesurfer,\n            originalArgs: originalArgs\n          });\n        });\n      }); // add regions and hook up callbacks to region objects\n\n      for (newRegionId in regions) {\n        if ({}.hasOwnProperty.call(regions, newRegionId) && wavesurfer && wavesurfer.addRegion) {\n          this._hookUpRegionEvents(wavesurfer.addRegion(regions[newRegionId]));\n        }\n      }\n    }\n  }, {\n    key: '_hookUpRegionEvents',\n    value: function _hookUpRegionEvents(region) {\n      var _this4 = this;\n\n      REGION_EVENTS.forEach(function (e) {\n        var propCallback = _this4.props['onSingleRegion' + capitalizeFirstLetter(e)];\n\n        var wavesurfer = _this4.props.wavesurfer;\n\n        if (propCallback) {\n          region.on(e, function () {\n            for (var _len2 = arguments.length, originalArgs = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n              originalArgs[_key2] = arguments[_key2];\n            }\n\n            propCallback({\n              wavesurfer: wavesurfer,\n              originalArgs: originalArgs,\n              region: region\n            });\n          });\n        }\n      });\n      region.on('remove', function () {\n        REGION_EVENTS.forEach(function (e) {\n          region.un(e);\n        });\n      });\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      return false;\n    }\n  }]);\n  return Regions;\n}(React.Component);\n\nRegions.propTypes = {\n  isReady: PropTypes.bool,\n  regions: PropTypes.object,\n  wavesurfer: PropTypes.object\n};\nRegions.defaultProps = {\n  regions: []\n};\n\nvar ReactWaves = function (_React$Component) {\n  inherits(ReactWaves, _React$Component);\n\n  function ReactWaves(props) {\n    classCallCheck(this, ReactWaves);\n\n    var _this = possibleConstructorReturn(this, (ReactWaves.__proto__ || Object.getPrototypeOf(ReactWaves)).call(this, props));\n\n    _this.onPosChange = function (e) {\n      var pos = e.originalArgs && e.originalArgs[0];\n      var duration = e.wavesurfer && e.wavesurfer.getDuration();\n\n      if (_this.props.onPosChange) {\n        _this.props.onPosChange(pos, e.wavesurfer);\n      } else if (pos && pos !== _this.state.pos) {\n        _this.setState({\n          pos: pos,\n          duration: duration\n        });\n      }\n    };\n\n    _this.state = {\n      pos: _this.props.pos,\n      duration: _this.props.duration\n    };\n    return _this;\n  }\n\n  createClass(ReactWaves, [{\n    key: 'componentWillReceiveProps',\n    value: function componentWillReceiveProps(nextProps) {\n      if (this.props.audioFile && nextProps.audioFile) {\n        this.setState({\n          pos: nextProps.pos,\n          duration: nextProps.duration\n        });\n      }\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      return React.createElement('div', {\n        className: styles.reactWaves + (this.props.className ? ' ' + this.props.className : '')\n      }, React.createElement(Waveform, _extends({}, this.props, {\n        pos: this.state.pos,\n        duration: this.state.duration,\n        onPosChange: this.onPosChange,\n        playing: this.props.playing\n      })));\n    }\n  }]);\n  return ReactWaves;\n}(React.Component);\n\nReactWaves.propTypes = {\n  playing: PropTypes.bool,\n  pos: PropTypes.number,\n  audioFile: function audioFile(props, propName, componentName) {\n    var prop = props[propName];\n\n    if (prop && typeof prop !== 'string' && !(prop instanceof window.Blob) && !(prop instanceof window.File)) {\n      return new Error('Invalid ' + propName + ' supplied to ' + componentName + '\\n        expected either string or file/blob');\n    }\n\n    return null;\n  },\n  mediaElt: PropTypes.oneOfType([PropTypes.string, PropTypes.instanceOf(window.HTMLElement)]),\n  audioPeaks: PropTypes.array,\n  volume: PropTypes.number,\n  zoom: PropTypes.number,\n  onPosChange: PropTypes.func,\n  children: PropTypes.oneOfType([PropTypes.element, PropTypes.array]),\n  options: PropTypes.shape({\n    audioRate: PropTypes.number,\n    audioContext: PropTypes.object,\n    audioScriptProcessor: PropTypes.object,\n    autoCenter: PropTypes.bool,\n    backend: PropTypes.oneOf(['WebAudio', 'MediaElement']),\n    barGap: positiveIntegerProptype,\n    barHeight: positiveIntegerProptype,\n    barWidth: function barWidth(props, propName, componentName) {\n      var prop = props[propName];\n\n      if (prop !== undefined && typeof prop !== 'number') {\n        return new Error('Invalid ' + propName + ' supplied to ' + componentName + '\\n          expected either undefined or number');\n      }\n\n      return null;\n    },\n    closeAudioContext: PropTypes.bool,\n    cursorColor: PropTypes.string,\n    cursorWidth: positiveIntegerProptype,\n    fillParent: PropTypes.bool,\n    forceDecode: PropTypes.bool,\n    height: positiveIntegerProptype,\n    hideScrollbar: PropTypes.bool,\n    interact: PropTypes.bool,\n    loopSelection: PropTypes.bool,\n    maxCanvasWidth: positiveIntegerProptype,\n    mediaControls: PropTypes.bool,\n    mediaType: PropTypes.oneOf(['audio', 'video']),\n    minPxPerSec: positiveIntegerProptype,\n    normalize: PropTypes.bool,\n    partialRender: PropTypes.bool,\n    pixelRatio: PropTypes.number,\n    progressColor: PropTypes.string,\n    removeMediaElementOnDestroy: PropTypes.bool,\n    renderer: PropTypes.object,\n    responsive: PropTypes.bool,\n    scrollParent: PropTypes.bool,\n    skipLength: PropTypes.number,\n    splitChannels: PropTypes.bool,\n    waveColor: PropTypes.oneOfType([PropTypes.string, PropTypes.instanceOf(window.CanvasGradient)]),\n    xhr: PropTypes.object\n  })\n};\nReactWaves.defaultProps = {\n  audioFile: '',\n  volume: 1,\n  zoom: 1,\n  options: {\n    barGap: 0,\n    barHeight: 2,\n    cursorWidth: 0,\n    height: 200,\n    hideScrollbar: true,\n    progressColor: '#EC407A',\n    responsive: true,\n    waveColor: '#D1D6DA'\n  },\n  pos: 0,\n  playing: false\n};\nexport default ReactWaves;\nexport { Regions };","map":null,"metadata":{},"sourceType":"module"}